/* elpi: embedded lambda prolog interpreter                                  */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

% --------- HOAS or programs  ------------------------------------------------

kind typ type. %%%%% types %%%%%%

type arrow typ -> typ -> typ.
type tconst string -> typ.
type tapp list typ -> typ.
type prop typ.
type forall (typ -> typ) -> typ. % polymorphic type declarations
type ctype string -> typ.


kind mode type. %%%%% modes %%%%%%
type mode-fo prop -> mode. % prop is eaither true of false
type mode-ho prop -> list mode -> mode.
typeabbrev modes (list mode).

kind functionality type.
type functionality prop -> (list functionality) -> functionality.

kind term type.
type app list term -> term.
type lam (term -> term) -> term.
type const string -> term.
type cdata string -> term.
type arg (term -> term) -> term.

kind clause type.
type clause ctype "Loc.t" -> list string -> term -> clause.
% --------- utils  ---------------------------------------------------------

type (`:) term -> typ -> entry.
type (`:=) string -> typ -> entry.

% --------- error reporting  ------------------------------------------------
kind err type.
type type-err term -> typ -> typ -> err.
type wrong-arity term -> typ -> list term -> err.
type unknown term -> err.
type assert prop -> err -> prop.

pred error i:list (pair (ctype "Loc.t") string), o:bool.

:name "default-typechecking-error"
error Msg tt :- std.forall Msg (x\ sigma L M\ fst x L, snd x M, print L "Error:" M).

pred warning i:(ctype "Loc.t"), o:string.
:name "default-typechecking-warning"
warning Loc Msg :- print Loc "Warning:" Msg.

pred assert i:prop, i:err.
assert P _ :- P, !.
assert _ (type-err T Ty ETy) :- !,
  checking LOC,
  ppt Ty TyPP, ppt ETy ETyPP,
  if (TyPP = ETyPP) (term_to_string Ty TyS, term_to_string ETy ETyS) (TyS = TyPP, ETyS = ETyPP),
  MSG is {pp T} ^ " has type " ^ TyS ^
         " but is used with type " ^ ETyS,
  error [pr LOC MSG] _.
assert _ (wrong-arity T Ty A) :- !,
  checking LOC,
  MSG is {pp T} ^ " has type " ^ {ppt Ty} ^
          " but is applied to " ^ {pp-list A},
  error [pr LOC MSG] _.

pred stash-new i:A, i:B.
stash-new E S :- open_safe E L, ( std.mem! L S ; stash_in_safe E S ), !.

pred report-all-failures-if-no-success o:A, o:B.
report-all-failures-if-no-success P RC :-
  new_safe E,
  (((pi ML\ error ML _ :- !, std.forall ML (stash-new E), fail) => P)
   ;
   (error {open_safe E} RC)).
pred report-all-failures-and-fail-if-no-success o:A, o:B.
report-all-failures-and-fail-if-no-success P RC :-
  new_safe E,
  (((pi ML\ error ML _ :- !, std.forall ML (stash-new E), fail) => P)
   ;
   (error {open_safe E} RC, fail)).

pred pp i:term, o:string.
pp (app [@VDASH, HD | L]) R :- !, R is "(" ^ {pp HD} ^ " :- " ^ {pp-list L} ^ ")".
pp (app [@IMPL, HD | L]) R :- !, R is "(" ^ {pp HD} ^ " => " ^ {pp-list L} ^ ")".
pp (app L) T1 :- !, pp-list L T, T1 is "(" ^ T ^ ")".
pp (lam F) T :- !, pi x\ term_to_string x XS, (pp x XS :- !) => pp (F x) T.
pp (const "discard") "_" :- !.
pp (const S) S :- !.
pp (cdata X) S :- !, term_to_string X S.
pp (arg A) R :- pi x\ pp (A x) Y, pp x X, R is "arg " ^ X ^ "\ " ^ Y.
pp X XS :- term_to_string X XS.

pred pp-list i:list term, o:string.
pp-list [X] Y :- !, pp X Y.
pp-list [X|XS] Y :- pp-list XS XSS, pp X XT, Y is XT ^ " " ^ XSS.
pp-list [] "".

pred ppt i:typ, o:string.
ppt (ctype S) X :- !, X is "(ctype " ^ S ^ ")".
ppt (tconst X) X :- !.
ppt (tapp L) X :- !, ppt-list L T, X is "(" ^ T ^ ")".
ppt (arrow A B) S :- !, ppt A AS, ppt B BS, S is "(" ^ AS ^ " -> " ^ BS ^ ")".
ppt X Y :- term_to_string X Y.

pred ppt-list i:list typ, o:string.
ppt-list [X] Y :- !, ppt X Y.
ppt-list [X|XS] Y :- ppt-list XS XSS, ppt X XT, Y is XT ^ " " ^ XSS.
ppt-list [] "".

% --------- typing  -------------------------------------------------------

pred unif i:typ, i:typ.
unif A B :- (A = B ; rm-any-variadic A A1, rm-any-variadic B B1, A1 = B1), !.

pred rm-any-variadic i:typ, o:typ.
rm-any-variadic (tconst S as C) X :- !, if (S = "any") (X = FRESH_) (X = C).
rm-any-variadic (tapp [tconst "variadic",_,X]) X1 :- !, rm-any-variadic X X1.
rm-any-variadic (tapp L) (tapp L1) :- !, rm-any-variadic-list L L1.
rm-any-variadic (ctype _ as X) X.
rm-any-variadic prop prop.
rm-any-variadic (arrow A1 B1) (arrow A2 B2) :- rm-any-variadic A1 A2, rm-any-variadic B1 B2.
rm-any-variadic (uvar as X) X.

pred rm-any-variadic-list i:list typ, o:list typ.
rm-any-variadic-list [] [].
rm-any-variadic-list [X|XS] [Y|YS] :- rm-any-variadic X Y, rm-any-variadic-list XS YS.

:index(2)
pred of i:term, o:typ.

of (cdata CData) Ty :-
  is_cdata CData (ctype CTy), !,
  assert (unif Ty (ctype CTy)) (type-err (cdata CData) (ctype CTy) Ty).

of (app [HD|ARGS]) TY :- !, 
  report-all-failures-if-no-success % HD may have multiple types
   (of HD HDTY, of-app HDTY ARGS TY HD (Done - Done)) _.
of (lam F) (arrow T B) :- !, pi x\
  (of x T :- !) => of (F x) B.

pred of-app i:typ i:list term, o:typ, o:term, o:A.

:if "DEBUG:CHECKER"
of-app Ty Args Tgt Hd _ :-
  print {trace.counter "run"} "of-app" {pp Hd} ":" {ppt Ty} "@" {pp-list Args} "=" {ppt Tgt}, fail.

of-app (tapp [tconst "variadic", T, _] as V) [X|XS] TGT HD (B - BT) :- !,
  of X TX, assert (unif T TX) (type-err X TX T), BT = X :: TL, of-app V XS TGT HD (B - TL).
of-app (tapp [tconst "variadic", _, TS]) [] TGT HD (D - []) :- !,
  assert (unif TGT TS) (type-err (app [HD|D]) TS TGT).
of-app (arrow T TS) [X|XS] TGT HD (B - BT) :- !,
  of X TX, assert (unif T TX) (type-err X TX T), BT = X :: TL, of-app TS XS TGT HD (B - TL).
of-app (uvar as ARR)  [X|XS] TGT HD (B - BT) :- !,
  of X T, ARR = arrow T TS, BT = X :: TL, of-app TS XS TGT HD (B - TL).
of-app Ty [] TGT HD (D - []) :- !,
  assert (unif TGT Ty) (type-err (app [HD|D]) Ty TGT).
of-app (uvar as Ty)  [] TGT HD (D - []) :- !,
  assert (unif TGT Ty) (type-err (app [HD|D]) Ty TGT).

of-app Ty Args _ HD (D - []) :- !,
  assert false (wrong-arity (app [HD|D]) Ty Args).

pred of-clause i:list string, i:term.
of-clause [N|NS] (arg C) :- !, pi x\ 
 (pp x N :- !) => (pi Tf\ of x Tf :- !, assert (unif T Tf) (type-err x T Tf)) =>
 of-clause NS (C x).
of-clause [] (arg C) :- !, pi x\ 
 (pi Tf\ of x Tf :- !, assert (unif T Tf) (type-err x T Tf)) =>
 of-clause [] (C x).
of-clause _ C :- of C TC, assert (unif TC prop) (type-err C TC prop).

type checking (ctype "Loc.t") -> prop.

pred log-tc-clause i:(ctype "Loc.t"), i:term.
:if "DEBUG:CHECKER"
log-tc-clause Loc Query :- !, print {trace.counter "run"} "typecheck" Loc Query.
log-tc-clause _ _.

pred typecheck i:list clause, i:clause, i:float, i:A, i:B.
typecheck P _ T0 NP _RC :- D is {gettimeofday} - T0, D > 10.0, !,
  print "[skipping" {std.length P} "clauses out of" NP "due to time limit]".

typecheck [] (clause Loc Names Query) _ _ RC :-
  log-tc-clause Loc Query,
  checking Loc =>
    report-all-failures-if-no-success (of-clause Names Query) RC.
typecheck [ (clause Loc Names Clause) | Rest] Q T0 NP RC :-
  % print "Typechecking Clause" Names Clause,
  log-tc-clause Loc Clause,
  checking Loc =>
    report-all-failures-if-no-success (of-clause Names Clause) RC, !,
  typecheck Rest Q T0 NP RC.

% mode (refresh i o).
pred refresh i:typ, o:typ.
refresh (forall F) T :- !, refresh (F FRESH_) T.
refresh (tconst "any") FRESH_ :- !.
refresh X X.

% mode (safe-dest-app i o o).
pred safe-dest-app i:term, o:term, o:list term.
safe-dest-app (app [X | A]) X A :- !.
safe-dest-app X X [].

pred collect-symbols-term i:term, i:A, o:A.
collect-symbols-term N X X :- name N, !.
collect-symbols-term (cdata _) X X :- !.
collect-symbols-term (app []) X X :- !.
collect-symbols-term (app [HD|L]) Acc Res :- !,
  collect-symbols-term HD Acc Acc1,
  collect-symbols-term (app L) Acc1 Res.
collect-symbols-term (lam F) Acc Res :- !,
  pi x\ collect-symbols-term (F x) Acc Res.
collect-symbols-term (arg F) Acc Res :- !,
  pi x\ collect-symbols-term (F x) Acc Res.
collect-symbols-term (const S) Acc Res :- !,
  if (std.string.map.mem S Acc) (Res = Acc)
     (checking Loc, std.string.map.add S Loc Acc Res).

pred collect-symbols-clause i:clause, i:A, o:A.
collect-symbols-clause (clause Loc _ C) Acc Res :-
  checking Loc => collect-symbols-term C Acc Res.

pred collect-symbols-program i:list clause, i:A, o:A.
collect-symbols-program [ C | P ] Acc Res :-
  collect-symbols-clause C Acc Acc1,
  collect-symbols-program P Acc1 Res.
collect-symbols-program [] X X.

pred under-env i:A, i:B.

type known term -> prop.

pred similar i:A, i:B.
similar S1 S2 :-
  R is ".*\\." ^ {rex_replace "[\\+\\*]" "." S2},
  rex_match R S1.

pred filter-similar i:A, i:B, o:C.
filter-similar [] _ [].
filter-similar [const K `: _ |KS] S [K|R] :- similar K S, !, filter-similar KS S R.
filter-similar [_|KS] S R :- filter-similar KS S R.

pred str_concat i:list string, o:string.
str_concat [] "".
str_concat [S|SS] R :- str_concat SS RR, R is S ^ " " ^ RR.

pred warn-undeclared i:A, i:B, o:C.
warn-undeclared _Known (pr ( "main") _) ff :- !.
warn-undeclared _ (pr ( S) _) ff :- rex_match ".*\\.aux" S, !.
warn-undeclared _ (pr ( S) _) ff :- rex_match ".*\\.aux\\." S, !.
warn-undeclared Known (pr ( S) LOC) tt :-
  filter-similar Known S Hints,
  if (Hints = []) (H = "") (H is " Did you mean " ^ {str_concat Hints} ^ "?"),
  MSG is "constant " ^ S ^ " has no declared type." ^ H,
  warning LOC MSG.

pred forall_uto10 i:A, i:B, i:C.
forall_uto10 [] _ _ :- !.
forall_uto10 [X|XS] N P :- /*N < 10,*/ !,
  P X Done, !,
  if (Done = tt) (M is N + 1) (M = N),
  forall_uto10 XS M P.
forall_uto10 ([pr _ LOC|_] as L) _ _ :-
  Msg is "[suppressing " ^ {term_to_string {std.length L}} ^ " warnings]",
  warning LOC Msg.
  
pred under-decl-env i:A, i:B.
under-decl-env [] P :- P.
under-decl-env [ X `: PT | XS ] P :-
  %print "Assume" X PT,
  (pi Ty\ of X Ty :- refresh PT Ty) => known X => under-decl-env XS P.

pred under-undecl-env i:list (pair string A), i:prop.
under-undecl-env [] P :- P.
under-undecl-env [ pr X _ | XS ] P :-
  %print "Assume" X PT,
  (of (const X) Ty_ :- !) => under-undecl-env XS P.

pred rm-known i:A, i:B, o:C.
rm-known (const N `: _) S S1 :- std.string.map.remove N S S1.

pred timing i:string, i:prop.
:if "TIME:CHECKER"
timing S P :- !, std.time P Time, print S Time.
timing _ P :- P.

pred check-all-symbols i:std.string.map loc.
:name "check-all-symbols:main"
check-all-symbols _.

pred typecheck-program i:A, i:B, i:C, o:D.
:name "typecheck-program:main"
typecheck-program P Q DeclaredTypes RC :-
  KnownTypes = [
    ((const "pi") `: forall x\ (arrow (arrow x prop) prop)),
    ((const "sigma") `: forall x\ (arrow (arrow x prop) prop)),
    ((const "discard") `: forall x\ x)|DeclaredTypes],
  timing "collect prog" (collect-symbols-program P {std.string.map.empty} TMP),
  collect-symbols-clause Q TMP AllSymbols,
  check-all-symbols AllSymbols,
  std.fold KnownTypes AllSymbols rm-known Unknown,
  std.string.map.bindings Unknown Undeclared,
  forall_uto10 {std.rev Undeclared} 0 (warn-undeclared KnownTypes), !,
  timing "typecheck "
         (under-decl-env {std.rev KnownTypes}
           (under-undecl-env Undeclared
             (typecheck P Q {gettimeofday} {std.length P} RC))).

% ---------- warnings ------------------------------------------------------
% elpi:skip 1
infix >>> 141.

type (>>>) term -> int -> entry.
type variable term -> prop.

pred silence-linear-warning i:string.
silence-linear-warning VN :- rex_match "^_.*" VN ; rex_match ".*_$" VN.

pred report-linear i:A.
report-linear [].
report-linear [(V >>> 1 + uvar) |NS] :- !,
  pp V VN,
  if (not(silence-linear-warning VN))
    (checking LOC,
     MSG is VN ^" is linear: name it _" ^ VN ^
         " (discard) or " ^ VN ^ "_ (fresh variable)",
     warning LOC MSG)
    true,
  report-linear NS.
report-linear [(V >>> uvar) |NS] :-
  pp V VN,
  if (not(silence-linear-warning VN))
    (checking LOC, MSG is VN ^" is unused", warning LOC MSG)
    true,
  report-linear NS.
report-linear [(_ >>> _) | NS] :- report-linear NS.

pred count i:A, i:list B.
count (lam F) E :- pi x\ count (F x) E.
count (app [X|XS]) E :- !, count X E, count (app XS) E.
count (app []) _ :- !.
count X E :- variable X, !, incr X E.
count _ _.

pred incr i:A, i:B.
incr X [(X >>> K) | _] :- add1 K.
incr X [_ | XS] :- incr X XS.

pred add1 i:A.
add1 (uvar as K) :- K = 1 + FRESH_.
add1 (1 + K) :- add1 K.

pred check-non-linear i:A, i:B, i:C.
check-non-linear [N|NS] (arg C) L :- pi x\
 (pp x N :- !) => (variable x) => check-non-linear NS (C x) [(x >>> FRESH_) | L].
check-non-linear [] (arg C) L :- pi x\
 (variable x) => check-non-linear _ (C x) [(x >>> FRESH_) | L].
check-non-linear _ C L :-
  count C L, report-linear L.

pred warn-linear i:A.
:name "warn-linear:main"
warn-linear [].
warn-linear [ (clause Loc Names Clause) |CS] :-
  checking Loc =>  check-non-linear Names Clause [],
  warn-linear CS.

% ---------- test ----------------------------------------------------------

main.

% ------- entry ---------------------------------------

pred type->ppt-clause i:A, i:B, i:C, o:D.
type->ppt-clause S ACC (forall F) (pi C) :- !,
  pi x\ type->ppt-clause S [x|ACC] (F x) (C x).
type->ppt-clause S [] T (pi Str\ ppt T Str :- !, ppt (tconst S) Str).
type->ppt-clause S ACC T (pi Str\ ppt T Str :- !, ppt (tapp [tconst S|Args]) Str) :- std.rev ACC Args.

pred compile-type-abbreviations i:A, o:B.
compile-type-abbreviations [] [].
compile-type-abbreviations [(_ `:= tconst _)|TS] Clauses :- !,
  % we don't refold immediate aliases
  compile-type-abbreviations TS Clauses.
compile-type-abbreviations [(X `:= ctype Y)|TS] Clauses :- not(X = Y), !,
  % we don't refold immediate aliases
  compile-type-abbreviations TS Clauses.
compile-type-abbreviations [(S `:= T)|TS] [Clause|Clauses] :-
  type->ppt-clause S [] T Clause,
  compile-type-abbreviations TS Clauses.

pred pp-var i:term, i:string, o:prop.
pp-var V S R :- var V, !, R = (pi x\ pp x S :- var V, same_term x V, !).

pred get-head-mode i:mode, o:prop.
get-head-mode (mode-fo M) M :- !.
get-head-mode (mode-ho M _) M :- !.

macro @VDASH :- const ":-".
macro @CUT :- const "!".
macro @COMMA :- const ",".
macro @PI :- const "pi".
macro @SIGMA :- const "sigma".
macro @IMPL :- const "=>".

pred head-symbol i:term, o:string.
head-symbol uvar _ :- halt "NYI".
head-symbol (arg Ag) S :- !, pi x\ head-symbol (Ag x) S.
head-symbol (const C) C :- !.
head-symbol (app [@VDASH, X | _]) S :- !, head-symbol X S.
head-symbol (app [@PI, lam B]) S :- !, pi x\ head-symbol (B x) S.
head-symbol (app [const C|_]) C :- !.
head-symbol X Y :- name X, !, std.any->string X Y.
head-symbol A _ :- halt "[head-symbol] uncaught branch" A.

pred head-term i:term, o:term.
head-term (uvar A) (uvar A) :- !.
head-term (arg Ag) S :- !, pi x\ head-term (Ag x) S.
head-term (const C) (const C) :- !.
head-term (app [@VDASH, X | _]) S :- !, head-term X S.
head-term (app [@PI, lam B]) S :- !, pi x\ head-term (B x) S.
head-term (app [const C|_]) (const C) :- !.
head-term X X :- name X, !.
head-term A _ :- halt "[head-term] uncaught branch" A.

pred copy i:term, o:term.
copy N N :- name N, !.
copy (cdata _ as X) X :- !.
copy (app L) (app L'):- !, std.map L copy L'.
copy (lam F) (lam F') :- !, pi x\ copy (F x) (F' x).
copy (const T) (const T) :- !.
copy A A :- var A, !.
copy A _ :- halt "Error in copy" A.

namespace modes {
  pred get-mode i:string, o:modes.
  
  pred load-mode i:pair term modes, o:prop.
  load-mode (pr (const T) M) (get-mode T M :- !).

  pred load-modes i:list (pair term modes), o:list prop.
  load-modes L M :- std.map L load-mode M.

  pred build-mode i:list A, o:list mode.
  build-mode L R :- std.map L (x\r\ r = mode-fo false) R.

  pred get-mode-safe i:term, i:list term, o:modes.
  get-mode-safe uvar Args M :- build-mode Args M, !. 
  get-mode-safe X _    M :- modes.get-mode {head-symbol X} M, !.
  get-mode-safe _ Args M :- build-mode Args M, !. 

}

namespace mode-checking {
  shorten modes.{get-mode-safe}.

  macro @rigid-term :- (const "rigid-term").

  pred loc o:(ctype "Loc.t").
  pred to-constant i:term.
  to-constant V :- V = @rigid-term.

  pred to-rigid-term i:term.
  to-rigid-term T :- (pi x\ copy x _ :-  var x, !, to-constant x) => copy T _.

  pred is-rigid-term i:term.
  to-rigid-term T :- (pi x\ copy x _ :-  var x, !, fail) => copy T _.

  pred set-head-mode i:term, i:list term.
  set-head-mode Head Args :-
    get-mode-safe Head Args Mode, !,
    loc Loc,
    if ({std.length Mode} = {std.length Args}) 
      (std.forall2 Mode Args (m\t\ if (get-head-mode m true) (to-rigid-term t) true)) 
      (print "Invalid mode length for (2)" Head Loc).
  set-head-mode _ _.

  pred get-vars i:term, o:list string.
  get-vars N [] :- name N, !.
  get-vars (cdata _) [] :- !.
  get-vars (const _) [] :- !.
  get-vars (app L) L'' :- !, std.map L get-vars L', std.flatten L' L''.
  get-vars (lam F) L :- !, pi x\ get-vars (F x) L.
  get-vars A [B] :- var A, !, pp A B.
  get-vars A _ :- halt "Error in get-vars" A.

  pred check-head-output i:term, i:list term.
  check-head-output Head Args :-
    get-mode-safe Head Args Mode, !, 
    loc Loc, pp Head HeadS,
    std.forall2 Mode Args (m\t\ sigma Vars\
      std.assert! (get-vars t Vars) "Should not fail",
      if (get-head-mode m true; Vars = []) true (
        print "WARNING: The variables" Vars "are in output position of the predicate\"" HeadS 
          "\"and cannot be ensured to be ground" Loc)).
  check-head-output _ _.

  pred variadic-mode i:term.
  variadic-mode (const "halt").
  variadic-mode (const "print").

  pred is-ho-predicate i:term.
  is-ho-predicate (@rigid-term).

  pred check-args-mode i:term, i:mode, i:term.
  check-args-mode HD Mode Arg :-
    get-head-mode Mode true, 
    get-vars Arg L, not (L = []), !,
    print "WARNING: Not ground" {pp Arg} "passed to" {pp HD} {loc}.
  % TODO: following rule aims to go under lambda which are args of a predicate
  %       however, this is gives a error if partial application is used
  % check-args-mode _ Loc Mode Arg :-
  %   Mode, Arg = lam L, !,
  %   print ("Going under lambda") Arg,
  %   pi x\ std.assert!(check-well-moded-negative Loc (L x)) "Should not fail".
  check-args-mode _ Mode _   :- get-head-mode Mode true, !.
  check-args-mode _ Mode Arg :- get-head-mode Mode false, to-rigid-term Arg.

  pred check-well-moded-negative i:term.
  check-well-moded-negative N :- name N, !.
  check-well-moded-negative (cdata _) :- !.
  check-well-moded-negative (const _) :- !.
  check-well-moded-negative (app [@COMMA | L]) :- !,
    loc Loc,
    std.forall L (x\ 
      if (var x) 
        (print "WARNING: Passed flexible to ," Loc) 
        (check-well-moded-negative x)).
  check-well-moded-negative (app [@PI, lam B]) :- !,
    pi x\ check-well-moded-negative (B x).
  check-well-moded-negative (app [@IMPL, Hyp, Body]) :- !,
    check-well-moded-positive Hyp [],
    check-well-moded-negative Body.
  check-well-moded-negative (app [HD|_]) :- variadic-mode HD, !.
  check-well-moded-negative (app [HD|Args]) :- !,
    if (var HD) (print "WARNING: Flex head symbol" HD "at" {loc}) true,
    get-mode-safe HD Args Mode,
    if ({std.length Mode} = {std.length Args}) 
      (std.forall2 Mode Args (x\y\std.assert!(check-args-mode HD x y) "Mh")) 
      (print "Invalid mode length for" HD {loc}).
  check-well-moded-negative (lam F) :- !, 
    pi x\ check-well-moded-negative (F x).

  pred check-well-moded-negative-list i:list term.
  check-well-moded-negative-list [] :- !.
  check-well-moded-negative-list [X | Xs] :-
    check-well-moded-negative X,
    check-well-moded-negative-list Xs.

  pred to-check i:string.
  to-check _ :- false, !.

  pred check-well-moded-positive-ho-mode i:list term, i:list mode, i:list term.
  check-well-moded-positive-ho-mode [A|As] [mode-fo X|Ms] Prem :- !,
    if X (to-rigid-term A) true, 
    check-well-moded-positive-ho-mode As Ms Prem.
  check-well-moded-positive-ho-mode [A|As] [mode-ho true M|Ms] Prem :- var A, !,
    pi x\ (pi X\ copy X x :- same_term X A, !) => std.map Prem copy (Prem' x), !, 
    head-symbol x HS,
    modes.get-mode HS M =>
    check-well-moded-positive-ho-mode As Ms (Prem' x).
  check-well-moded-positive-ho-mode [_|As] [_|Ms] Prem :- !,
    check-well-moded-positive-ho-mode As Ms Prem.
  check-well-moded-positive-ho-mode [] [] Prem :- check-well-moded-negative-list Prem.

  pred check-well-moded-positive i:term, i:list string.
  check-well-moded-positive uvar _ :- !, 
    print "WARNING: Got uvar in check well-moded-positive" {loc}.
  check-well-moded-positive (arg B) [N|Names] :- !,
    pp-var X N P, P => check-well-moded-positive (B X) Names.
  check-well-moded-positive (const _) _ :- !.
  check-well-moded-positive (app [@VDASH, (app [Head | Args]) | Prem]) Names_ :-
    check-well-moded-positive-ho-mode Args {get-mode-safe Head Args} Prem,
    check-head-output Head Args.
  check-well-moded-positive (app [@VDASH, (const _) | Prem]) Names_ :- !,
    check-well-moded-negative-list Prem.
  check-well-moded-positive (app [@PI, lam B]) Names :- !,
    check-well-moded-positive (B FRESH_) Names.
  check-well-moded-positive (app [@COMMA | L]) Names :- !,
    std.forall L (x\ check-well-moded-positive x Names).
  check-well-moded-positive (app ([const "::", A, L])) Names :- !,
    check-well-moded-positive A Names,
    check-well-moded-positive L Names.
  check-well-moded-positive (app _ as App) Names :- !, 
    check-well-moded-positive (app [@VDASH, App]) Names.
  check-well-moded-positive A _ :- 
    halt "[check-well-moded-positive] uncaught branch" A.

  pred check-well-moded-prog i:A.
  check-well-moded-prog [] :- !.
  check-well-moded-prog [clause Loc Vars Body | Tl] :- 
    to-check {head-symbol Body}, !,
    loc Loc => check-well-moded-positive Body Vars,
    check-well-moded-prog Tl.
  check-well-moded-prog [_ | Tl] :- 
    check-well-moded-prog Tl.
}


pred mem= i:list A, i:A.
mem= [A|_] B :- same_term A B, !.
mem= [_|A] B :- mem= A B.

namespace functionality {
  shorten modes.{get-mode-safe}.

  macro @not-func :- functionality false [].
  macro @c A :- const A.

  % Add the name of functional predicates by hand
  pred is-functional i:term, o:list functionality.
  is-functional (@c "=") [@not-func, @not-func].
  is-functional (@c "trace.counter") [@not-func, @not-func].
  is-functional (@c "debug-print") [@not-func, @not-func].
  is-functional (@c "not") [@not-func].
  is-functional (@c "is") [@not-func, @not-func].
  is-functional (@c "calc") [@not-func, @not-func].

  pred is-functional-variadic i:string.
  is-functional-variadic "halt".
  is-functional-variadic "print".

  pred current-pred o:string.

  pred pred-map i:string, o:clause.

  pred loc1 o:(ctype "Loc.t"). 
  pred loc2 o:(ctype "Loc.t"). 

  type func bool -> term. % Used by old1 and old2
  type v bool -> term -> term. 

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%% AUXILIARY FUNCTIONS %%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  pred rev_map i:list A, i:(pred i:A, o:B), o:list B.
  rev_map L F R :- rev_map.aux L F [] R.
  
  pred rev_map.aux i:list A, i:(pred i:A, o:B), i:list B, o:list B.
  rev_map.aux [] _ L L.
  rev_map.aux [A|As] F L L' :- F A B, !, rev_map.aux As F [B|L] L'.

  pred load-functional-prop i:(pair term (list functionality)), o:prop.
  load-functional-prop (pr (@c P) L) (is-functional (@c P) L) :- !.
  load-functional-prop A _ :- halt "Only const can be passed to pred load_functional_prop. Received" A.

  pred load-functional-props i:list (pair term (list functionality)), o:list prop.
  load-functional-props L S :- std.map L load-functional-prop S.

  pred normalize-term.aux i:term, o:term.
  normalize-term.aux (app [@VDASH | _] as A) A :- !.
  normalize-term.aux (const _ as A) (app [@VDASH, A]) :- !.
  normalize-term.aux (app _ as A) (app [@VDASH, A]) :- !.
  normalize-term.aux A _ :- halt "[normalize-term.aux] Unexpected branch" A.

  pred flatten-commas i:list term, o:list term. % STOP HERE
  flatten-commas [] [].
  flatten-commas [app[@COMMA|L]|TL] R :- !,
    flatten-commas L L1,
    flatten-commas TL L2,
    std.append L1 L2 R.
  flatten-commas [A|As] [A|As'] :- !, flatten-commas As As'.

  pred normalize-term i:term, o:term, o:list term.
  normalize-term A HD TL' :-
    std.assert!(normalize-term.aux A (app [@VDASH, HD | TL])) "[normalize-term] fail1",
    std.assert!(flatten-commas TL TL') "[normalize-term] fail2".

  pred build-pred-map i:pair string (list clause), o:list prop.
  build-pred-map (pr _ []) [].
  build-pred-map (pr A [X|Xs]) [pred-map A X|L] :- build-pred-map (pr A Xs) L.

  pred program2pred_buckets i:list clause, i:std.string.map (list clause), o:list prop, o:list (list clause).
  program2pred_buckets [] B C D :- 
    std.string.map.bindings B L', 
    std.map L' build-pred-map C', std.flatten C' C,
    std.map L' (x\r\ sigma A B Br\ x = pr A B, std.rev B Br, r = pr A Br) L,
    std.map L snd D.
  program2pred_buckets [Cl|As] B C D :-
    Cl = clause _ _ A,
    head-symbol A K, is-functional (const K) _, !,
    (std.string.map.find K B V; V = []), !,
    std.string.map.add K [Cl|V] B B1,
    program2pred_buckets As B1 C D.
  program2pred_buckets [_|As] B C D :- program2pred_buckets As B C D.

  pred go-under-arg.aux i:list string, i:term, i:(pred i:term, i:list term).
  go-under-arg.aux [N|Ns]  (arg B) F :- !,
    pp-var Fresh N PP,
    PP => go-under-arg.aux Ns (B Fresh) F.
  go-under-arg.aux _  (app [@PI, lam B]) F :- !, 
    go-under-arg.aux [] (B Fresh_) F.
  go-under-arg.aux []      T       F :- !, 
    std.assert!(normalize-term T HD TL) "[normalize-term] should not fail", !,
    F HD TL.
  go-under-arg.aux A B _ :- halt "[go-under-arg.aux] should not fail..." A B.

  pred go-under-term i:term, i:(pred i:term, i:list term).
  go-under-term A F :- go-under-arg.aux [] A F. 

  pred go-under-arg i:(pred o:A), i:clause, i:(pred i:term, i:list term).
  go-under-arg LocP (clause Loc Names T) Cont :-
    (LocP Loc :- !) => go-under-arg.aux Names T Cont.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%% CHECK OVERLAPPING HEADS %%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  pred overlapping-terms i:term, i:term.
  overlapping-terms uvar _ :- !.
  overlapping-terms _ uvar :- !.
  overlapping-terms X X :- name X.
  overlapping-terms (app X) (app Y) :- !, std.forall2 X Y overlapping-terms.
  overlapping-terms (lam X) (lam Y) :- !, pi x\ overlapping-terms (X x) (Y x).
  overlapping-terms (const X) (const X) :- !.
  overlapping-terms (cdata X) (cdata X) :- !.

  pred overlapping-head.aux i:modes, i:list term, i:list term.
  overlapping-head.aux [] [] [].
  overlapping-head.aux [M|Ms] [A|As] [B|Bs]  :- get-head-mode M true, !,
    overlapping-terms A B, overlapping-head.aux Ms As Bs.
  overlapping-head.aux [_|Ms] [_|As] [_|Bs] :- overlapping-head.aux Ms As Bs.

  pred overlapping-head i:term, i:term. % Takes 2 heads
  overlapping-head (app[A|As]) (app[B|Bs]) :- !,
    head-symbol A Ahs, head-symbol B Bhs, Ahs = Bhs, !,
    get-mode-safe A As M,
    overlapping-head.aux M As Bs, !.
  overlapping-head A B :- halt "[overlapping-head] uncaught branch" A B.

  pred cut-in-antecedent i:list term. % Takes the body
  cut-in-antecedent L :- mem= L @CUT, !.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%% CHECK FUNCTIONAL BODY %%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % [partition-cut L A B] if L = [p1, ..., pm, !, pn, ..., po] then
  %                          A = [p1, ..., pm] and B = [pn, ..., po]
  pred partition-cut i:list term, o:list term, o:list term.
  partition-cut [] [] [] :- !.
  partition-cut [@CUT|L] [] L :- !.
  partition-cut [A|B] [A|As] Bs :- partition-cut B As Bs. 

  pred split-functional-ctx i:list term, o:list term, o:list term.
  split-functional-ctx L Bef Aft :- 
    partition-cut {std.rev L} A B,
    std.rev B Bef, std.rev A Aft, !.
  split-functional-ctx _ _ _ :- halt "[split-functional-ctx] should not fail...".

  namespace old1 {
    /* Here we check that all the premise of the body are functional
     * and that all hyps do not break functionality
     */
    % THIS IS UNUSED, IN FAVOUR OF functional-dependecies
    pred functional-premise i:term.
    % BASE CASES
    functional-premise (cdata _) :- !.
    functional-premise (const _) :- !.
    functional-premise (uvar) :- halt "[functional-premise] found uvar..." {loc1}.
    % APP CASES
    functional-premise (app [@PI, lam B]) :- !, pi x\ functional-premise (B x).
    functional-premise (app [@SIGMA, lam B]) :- !, functional-premise (B X_).
    functional-premise (app [@IMPL, Hyp | Body]) :-
      head-symbol Hyp HypH, is-functional (const HypH) _, !,
      % here the hyp is declared functional, then we check it for funcitonality 
      Clause = clause {loc1} [] Hyp,
      std.findall (pred-map HypH _) ClausesL,
      std.map ClausesL (x\r\ pred-map _ r = x) Clauses,
      pred-map HypH Clause =>  (
        check-functionality-clause-clauses Clause Clauses,
        std.forall Body functional-premise).
    functional-premise (app [@IMPL, Hyp_ | Body]) :- !, % Hyp_ is not declared functional: ignore it
      std.forall Body functional-premise.
    functional-premise (app [@COMMA|L]) :- !, std.forall L functional-premise.
    functional-premise (app [const C | _]) :- % The premise is functional
      is-functional (const C) _L, !. % TODO: take into account _L...
    functional-premise (app [(const _ as H) | L]) :- % The premise mode are all input
      std.forall {get-mode-safe H L} (x\ get-head-mode x true), !.
    functional-premise A :- halt "[functional-premise] uncaught branch" A {loc1}.

    pred functional-body i:list term.
    % ALL PREMISES AFTER THE LAST CUT SHOULD BE FUNCTIONAL
    functional-body L :- % PROPOSITION 3.4
      split-functional-ctx L Bef_ Aft, 
      std.forall Aft functional-premise.
  }

  namespace old2 {
    pred set-var-functional-output i:mode, i:term.
    set-var-functional-output M T :- get-head-mode M false, !, % The output mode set T to functional
      (pi X\ copy (uvar as X) _ :- !, X = func tt) =>
      (pi X\ copy (func X) _ :- !, X = tt) => copy T _.
    set-var-functional-output _ _.

    pred set-vars-non-functional i:term.
    set-vars-non-functional T :-
      (pi X Y\ copy (uvar as X) _ :- !, X = func Y) => copy T _.

    pred functional-dependencies i:term. 
      /* THIS CHECK CLAUSES BEFORE AND AFTER BANG
       * enhancement of previous functional-premises
       * in particular if a atom is functional, its output are set to functional, too.
       * if the atom is not functional the output are set to maybe-functional
       * a clause is functional if all of its output position are set to functional
       * or are flexible
       * However, this assumption is no more true in this case:
       *   i o      o    i o
       * f X Y :- q Y, r X Y. 
       * Where: f and r are functional
       * The problem comes out if we have the query
       * (pi X\ r X X) => q 1 => q 2 => q Y, f X Y.
       * It is not true that Y is functionally determined by f
       */
    % BASE CASES
    functional-dependencies (cdata _) :- !.
    functional-dependencies (const _) :- !.
    functional-dependencies (func  _) :- !.
    functional-dependencies (uvar) :- halt "[functional-dependencies] found uvar..." {loc1}.
    % APP CASES
    functional-dependencies (app [@PI, lam B]) :- !, pi x\ functional-dependencies (B x).
    functional-dependencies (app [@SIGMA, lam B]) :- !, functional-dependencies (B X_).
    functional-dependencies (app [@IMPL, Hyp | Body]) :- % Hyp if functional
      head-symbol Hyp HypH, is-functional (const HypH) _, !,
      % here the hyp is declared functional, then we check it for funcitonality 
      Clause = clause {loc1} [] Hyp,
      std.findall (pred-map HypH _) ClausesL,
      std.map ClausesL (x\r\ pred-map _ r = x) Clauses,
      pred-map HypH Clause =>  (
        check-functionality-clause-clauses Clause Clauses,
        std.forall Body functional-dependencies).
    functional-dependencies (app [@IMPL, Hyp_ | Body]) :- !, % Hyp_ is not declared functional: ignore it
      std.forall Body functional-dependencies.
    functional-dependencies (app [@COMMA|L]) :- !, std.forall L functional-dependencies.
    functional-dependencies (app [(const Cs as C) | L]) :- % The premise is functional
      (all-funct; is-functional (const Cs) _FL), !, % TODO: _FL should be taken into account
      std.forall2 {get-mode-safe C L} L set-var-functional-output.
    functional-dependencies (app [(const _) | L]) :- !, % The premise is not functional
      std.forall L set-vars-non-functional.
    functional-dependencies A :- halt "[functional-dependencies] uncaught branch" A {loc1}.

    pred functional-body i:term, i:list term.
    functional-body H L :- % PROPOSITION 3.4
      split-functional-ctx L Bef Aft,
      head-symbol H HS,
      all-funct => std.forall Bef functional-dependencies,
      current-pred HS => std.forall Aft functional-dependencies,
      not(head-is-functional H),
      halt "[head-is-functional] the head of" {pp H} "cannot be guess to be functional..." {loc1}.
    functional-body _ _.
  }

  %%
  %% FUNCTIONAL DEPENDENCIES
  %%

  pred set-var-functional-all i:term.
  set-var-functional-all T :-
    loc1 Loc,
    Msg is ("Functional premise called with non functional argument\n" ^ {std.any->string Loc}),
    (pi X\ copy (func ff) _ :- halt Msg) =>
    (pi X\ copy (uvar as X) _ :- !, X = func tt) => copy T _.

  pred set-vars-non-functional-hard i:term.
  set-vars-non-functional-hard T :-
    loc1 Loc,
    Msg is ("Non functional premise produces a non functional value for is a functional place " ^ {pp T} ^ "\n" ^ {std.any->string Loc}),
    (pi X\ copy (func tt) _ :- halt Msg) =>
    (pi X\ copy (uvar as X) _ :- !, X = func ff) => copy T _.

  pred functional-dependencies1 i:term.
  % BASE CASES
  functional-dependencies1 (cdata _) :- !.
  functional-dependencies1 (const _) :- !.
  functional-dependencies1 (func  _) :- !.
  functional-dependencies1 (uvar as X) :- is-functional X _, !.
  functional-dependencies1 (uvar) :- print "[functional-dependencies1] WARNING found uvar..." {loc1}.
  % APP CASES
  functional-dependencies1 (app [@PI, lam B]) :- !, pi x\ functional-dependencies1 (B x).
  functional-dependencies1 (app [@SIGMA, lam B]) :- !, functional-dependencies1 (B X_).
  functional-dependencies1 (app [@IMPL, Hyp | Body]) :- % Hyp if functional
    head-symbol Hyp HypH, is-functional (const HypH) _, !,
    % here the hyp is declared functional, then we check it for funcitonality 
    Clause = clause {loc1} [] Hyp,
    std.findall (pred-map HypH _) ClausesL,
    std.map ClausesL (x\r\ pred-map _ r = x) Clauses,
    pred-map HypH Clause =>  (
      check-functionality-clause-clauses Clause Clauses,
      std.forall Body functional-dependencies1).
  functional-dependencies1 (app [@IMPL, Hyp_ | Body]) :- !, % Hyp_ is not declared functional: ignore it
    std.forall Body functional-dependencies1.
  functional-dependencies1 (app [@COMMA|L]) :- !, std.forall L functional-dependencies1.
  functional-dependencies1 (app [const C | L]) :- % The premise is functional
    is-functional (const C) _X, !, std.forall L set-var-functional-all. % TODO: _X should be used
  functional-dependencies1 (app [const C | L]) :- % The premise is functional
    is-functional-variadic C, !, std.forall L set-var-functional-all. % TODO: _X should be used
  functional-dependencies1 (app [const _ | L]) :- !, % The premise is not functional
    std.forall L set-vars-non-functional-hard.
  functional-dependencies1 A :- halt "[functional-dependencies1] uncaught branch" A {loc1}.

  pred all-funct.

  pred functional-body i:term, i:list term.

  pred head-is-functional i:term.
  head-is-functional T :- 
    (copy (func uvar) _ :- !, fail) => 
    (copy (func ff) _ :- !, fail) => copy T _.

  functional-body H L :- % PROPOSITION 3.4
    split-functional-ctx L Bef_ Aft,
    head-symbol H HS,
    % all-funct => std.forall Bef functional-dependencies1,
    % print "==========================",
    % print H L,
    current-pred HS => std.forall Aft functional-dependencies1,
    not(head-is-functional H),
    halt "[head-is-functional] the head of" {pp H} "cannot be guess to be functional..." {loc1}.
  functional-body _ _.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%% MAIN %%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  pred check-functionality-term-term i:term, i:list term, i:term, i:list term.
  check-functionality-term-term AH _ BH _ :-
    overlapping-head AH BH,
    halt "Clause" {pp AH} "overlaps with" 
                  {pp BH} "at" {loc1} "and" {loc2}.

  pred check-functionality-term-clauses i:term, i:list term, i:list clause.
  check-functionality-term-clauses _ _ [].
  check-functionality-term-clauses A ABo [Clause|_] :- % PROPOSITION 3.7
    go-under-arg loc2 Clause (check-functionality-term-term A ABo).
  check-functionality-term-clauses A ABo [_|Bs] :-
    check-functionality-term-clauses A ABo Bs. 

  pred add-functional-arguments-list i:list term, i:list functionality, o:list prop.
  add-functional-arguments-list [] [] [].
  add-functional-arguments-list [(uvar as U) | L] [functionality true F | FL] [P|Ps] :- !,
    P = (pi x\ is-functional (uvar as x) F :- same_term x U, !),
    add-functional-arguments-list L FL Ps.
  add-functional-arguments-list [const "discard" | L] [_ | FL] R :- !,
    add-functional-arguments-list L FL R.
  add-functional-arguments-list [T | L_] [functionality true FL_] [P_|Ps_] :-
    halt "[add-functional-arguments-list] NYI: get functional non flex arg" {pp T} {loc1}.
  add-functional-arguments-list [_ | L] [functionality false _ | FL] R :- !,
    add-functional-arguments-list L FL R.

  pred add-functional-arguments i:term, o:list prop.
  add-functional-arguments (const _) [] :- !.
  add-functional-arguments (app [const C|L]) R :- is-functional (const C) LF, !,
    add-functional-arguments-list L LF R.
  add-functional-arguments (app [const _|_]) [].

  pred check-functionality-clauses-term i:list clause, i:term, i:list term.
  check-functionality-clauses-term Clauses HD TL :-
    Msg is ("Body of " ^ {pp HD} ^ ":-" ^ {pp-list TL} ^ " is not functional"),
    add-functional-arguments HD FunctionalArgs,
    FunctionalArgs => std.assert! (functional-body HD TL) Msg,
    if (cut-in-antecedent TL) % PROPOSITION 3.6
        true
        (check-functionality-term-clauses HD TL Clauses).
  
  pred check-functionality-clause-clauses i:clause, i:list clause.
  check-functionality-clause-clauses Clause Clauses :-
    go-under-arg loc1 Clause (check-functionality-clauses-term Clauses).

  pred check-functionality-list i:list clause.
  check-functionality-list [].
  check-functionality-list [Clause|Clauses] :-
    check-functionality-clause-clauses Clause Clauses,
    check-functionality-list Clauses. 

  pred check-functionality i:list clause.
  check-functionality Program :-
    program2pred_buckets Program {std.string.map.empty} ProgramProps ProgramClauses,
    (pi x\ copy (func _ as x) x :- !) =>
      ProgramProps => std.forall ProgramClauses check-functionality-list.
}

pred check i:A, i:B, i:C, i:D, i:E, i:F.
:name "check:main"
check P Q DeclaredTypes TypeAbbreviations Modes FuncPred :-
  compile-type-abbreviations TypeAbbreviations Abbrevs,
  Abbrevs => typecheck-program P Q DeclaredTypes RC, !,
  warn-linear P, !,
  if (var RC) (true) (fail),
  modes.load-modes Modes ModesP,
  functionality.load-functional-props FuncPred FuncP,
  ModesP => FuncP => (
    functionality.check-functionality P,
    mode-checking.check-well-moded-prog P),
  true
  .

% vim: set ft=lprolog:
