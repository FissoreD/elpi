/* elpi: embedded lambda prolog interpreter                                  */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

% --------- HOAS or programs  ------------------------------------------------

kind typ type. %%%%% types %%%%%%

type arrow typ -> typ -> typ.
type tconst string -> typ.
type tapp list typ -> typ.
type prop typ.
type forall (typ -> typ) -> typ. % polymorphic type declarations
type ctype string -> typ.


kind mode type. %%%%% modes %%%%%%
type mode-fo prop -> mode. % prop is eaither true of false
type mode-ho prop -> list mode -> mode.
typeabbrev modes (list mode).

kind func type.
type fpred func.
type nfpred func.
type npred func.
type preserve func.

kind functionality type.
type functionality func -> (list functionality) -> functionality.

kind term type.
type app list term -> term.
type lam (term -> term) -> term.
type const string -> term.
type cdata string -> term.
type arg (term -> term) -> term.

kind clause type.
type clause ctype "Loc.t" -> list string -> term -> clause.
% --------- utils  ---------------------------------------------------------

type (`:) term -> typ -> entry.
type (`:=) string -> typ -> entry.

% --------- error reporting  ------------------------------------------------
kind err type.
type type-err term -> typ -> typ -> err.
type wrong-arity term -> typ -> list term -> err.
type unknown term -> err.
type assert prop -> err -> prop.

pred error i:list (pair (ctype "Loc.t") string), o:bool.

:name "default-typechecking-error"
error Msg tt :- std.forall Msg (x\ sigma L M\ fst x L, snd x M, print L "Error:" M).

pred warning i:(ctype "Loc.t"), o:string.
:name "default-typechecking-warning"
warning Loc Msg :- print Loc "Warning:" Msg.

pred assert i:prop, i:err.
assert P _ :- P, !.
assert _ (type-err T Ty ETy) :- !,
  checking LOC,
  ppt Ty TyPP, ppt ETy ETyPP,
  if (TyPP = ETyPP) (term_to_string Ty TyS, term_to_string ETy ETyS) (TyS = TyPP, ETyS = ETyPP),
  MSG is {pp T} ^ " has type " ^ TyS ^
         " but is used with type " ^ ETyS,
  error [pr LOC MSG] _.
assert _ (wrong-arity T Ty A) :- !,
  checking LOC,
  MSG is {pp T} ^ " has type " ^ {ppt Ty} ^
          " but is applied to " ^ {pp-list A},
  error [pr LOC MSG] _.

pred stash-new i:A, i:B.
stash-new E S :- open_safe E L, ( std.mem! L S ; stash_in_safe E S ), !.

pred report-all-failures-if-no-success o:A, o:B.
report-all-failures-if-no-success P RC :-
  new_safe E,
  (((pi ML\ error ML _ :- !, std.forall ML (stash-new E), fail) => P)
   ;
   (error {open_safe E} RC)).
pred report-all-failures-and-fail-if-no-success o:A, o:B.
report-all-failures-and-fail-if-no-success P RC :-
  new_safe E,
  (((pi ML\ error ML _ :- !, std.forall ML (stash-new E), fail) => P)
   ;
   (error {open_safe E} RC, fail)).

pred infix-op i:string.
infix-op ":-".
infix-op "=".
infix-op "::".
infix-op ":-".
infix-op "=>".
infix-op ",".

pred pp i:term, o:string.
pp (app [const C, HD | L]) R :- infix-op C, !, R is "(" ^ {pp HD} ^ " " ^ C ^ " " ^ {pp-list L} ^ ")".
pp (app L) T1 :- !, pp-list L T, T1 is "(" ^ T ^ ")".
pp (lam F) T :- !, pi x\ term_to_string x XS, (pp x XS :- !) => pp (F x) T.
pp (const "discard") "_" :- !.
pp (const S) S :- !.
pp (cdata X) S :- !, term_to_string X S.
pp (arg A) R :- pi x\ pp (A x) Y, pp x X, R is "arg " ^ X ^ "\ " ^ Y.
pp X XS :- term_to_string X XS', XS is "(" ^ XS' ^ ")".

pred pp-list i:list term, o:string.
pp-list [X] Y :- !, pp X Y.
pp-list [X|XS] Y :- pp-list XS XSS, pp X XT, Y is XT ^ " " ^ XSS.
pp-list [] "".

pred ppt i:typ, o:string.
ppt (ctype S) X :- !, X is "(ctype " ^ S ^ ")".
ppt (tconst X) X :- !.
ppt (tapp L) X :- !, ppt-list L T, X is "(" ^ T ^ ")".
ppt (arrow A B) S :- !, ppt A AS, ppt B BS, S is "(" ^ AS ^ " -> " ^ BS ^ ")".
ppt X Y :- term_to_string X Y.

pred ppt-list i:list typ, o:string.
ppt-list [X] Y :- !, ppt X Y.
ppt-list [X|XS] Y :- ppt-list XS XSS, ppt X XT, Y is XT ^ " " ^ XSS.
ppt-list [] "".

% --------- typing  -------------------------------------------------------

pred unif i:typ, i:typ.
unif A B :- (A = B ; rm-any-variadic A A1, rm-any-variadic B B1, A1 = B1), !.

pred rm-any-variadic i:typ, o:typ.
rm-any-variadic (tconst S as C) X :- !, if (S = "any") (X = FRESH_) (X = C).
rm-any-variadic (tapp [tconst "variadic",_,X]) X1 :- !, rm-any-variadic X X1.
rm-any-variadic (tapp L) (tapp L1) :- !, rm-any-variadic-list L L1.
rm-any-variadic (ctype _ as X) X.
rm-any-variadic prop prop.
rm-any-variadic (arrow A1 B1) (arrow A2 B2) :- rm-any-variadic A1 A2, rm-any-variadic B1 B2.
rm-any-variadic (uvar as X) X.

pred rm-any-variadic-list i:list typ, o:list typ.
rm-any-variadic-list [] [].
rm-any-variadic-list [X|XS] [Y|YS] :- rm-any-variadic X Y, rm-any-variadic-list XS YS.

:index(2)
pred of i:term, o:typ.

of (cdata CData) Ty :-
  is_cdata CData (ctype CTy), !,
  assert (unif Ty (ctype CTy)) (type-err (cdata CData) (ctype CTy) Ty).

of (app [HD|ARGS]) TY :- !, 
  report-all-failures-if-no-success % HD may have multiple types
   (of HD HDTY, of-app HDTY ARGS TY HD (Done - Done)) _.
of (lam F) (arrow T B) :- !, pi x\
  (of x T :- !) => of (F x) B.

pred of-app i:typ i:list term, o:typ, o:term, o:A.

:if "DEBUG:CHECKER"
of-app Ty Args Tgt Hd _ :-
  print {trace.counter "run"} "of-app" {pp Hd} ":" {ppt Ty} "@" {pp-list Args} "=" {ppt Tgt}, fail.

of-app (tapp [tconst "variadic", T, _] as V) [X|XS] TGT HD (B - BT) :- !,
  of X TX, assert (unif T TX) (type-err X TX T), BT = X :: TL, of-app V XS TGT HD (B - TL).
of-app (tapp [tconst "variadic", _, TS]) [] TGT HD (D - []) :- !,
  assert (unif TGT TS) (type-err (app [HD|D]) TS TGT).
of-app (arrow T TS) [X|XS] TGT HD (B - BT) :- !,
  of X TX, assert (unif T TX) (type-err X TX T), BT = X :: TL, of-app TS XS TGT HD (B - TL).
of-app (uvar as ARR)  [X|XS] TGT HD (B - BT) :- !,
  of X T, ARR = arrow T TS, BT = X :: TL, of-app TS XS TGT HD (B - TL).
of-app Ty [] TGT HD (D - []) :- !,
  assert (unif TGT Ty) (type-err (app [HD|D]) Ty TGT).
of-app (uvar as Ty)  [] TGT HD (D - []) :- !,
  assert (unif TGT Ty) (type-err (app [HD|D]) Ty TGT).

of-app Ty Args _ HD (D - []) :- !,
  assert false (wrong-arity (app [HD|D]) Ty Args).

pred of-clause i:list string, i:term.
of-clause [N|NS] (arg C) :- !, pi x\ 
 (pp x N :- !) => (pi Tf\ of x Tf :- !, assert (unif T Tf) (type-err x T Tf)) =>
 of-clause NS (C x).
of-clause [] (arg C) :- !, pi x\ 
 (pi Tf\ of x Tf :- !, assert (unif T Tf) (type-err x T Tf)) =>
 of-clause [] (C x).
of-clause _ C :- of C TC, assert (unif TC prop) (type-err C TC prop).

type checking (ctype "Loc.t") -> prop.

pred log-tc-clause i:(ctype "Loc.t"), i:term.
:if "DEBUG:CHECKER"
log-tc-clause Loc Query :- !, print {trace.counter "run"} "typecheck" Loc Query.
log-tc-clause _ _.

pred typecheck i:list clause, i:clause, i:float, i:A, i:B.
typecheck P _ T0 NP _RC :- D is {gettimeofday} - T0, D > 10.0, !,
  print "[skipping" {std.length P} "clauses out of" NP "due to time limit]".

typecheck [] (clause Loc Names Query) _ _ RC :-
  log-tc-clause Loc Query,
  checking Loc =>
    report-all-failures-if-no-success (of-clause Names Query) RC.
typecheck [ (clause Loc Names Clause) | Rest] Q T0 NP RC :-
  % print "Typechecking Clause" Names Clause,
  log-tc-clause Loc Clause,
  checking Loc =>
    report-all-failures-if-no-success (of-clause Names Clause) RC, !,
  typecheck Rest Q T0 NP RC.

% mode (refresh i o).
pred refresh i:typ, o:typ.
refresh (forall F) T :- !, refresh (F FRESH_) T.
refresh (tconst "any") FRESH_ :- !.
refresh X X.

% mode (safe-dest-app i o o).
pred safe-dest-app i:term, o:term, o:list term.
safe-dest-app (app [X | A]) X A :- !.
safe-dest-app X X [].

pred collect-symbols-term i:term, i:A, o:A.
collect-symbols-term N X X :- name N, !.
collect-symbols-term (cdata _) X X :- !.
collect-symbols-term (app []) X X :- !.
collect-symbols-term (app [HD|L]) Acc Res :- !,
  collect-symbols-term HD Acc Acc1,
  collect-symbols-term (app L) Acc1 Res.
collect-symbols-term (lam F) Acc Res :- !,
  pi x\ collect-symbols-term (F x) Acc Res.
collect-symbols-term (arg F) Acc Res :- !,
  pi x\ collect-symbols-term (F x) Acc Res.
collect-symbols-term (const S) Acc Res :- !,
  if (std.string.map.mem S Acc) (Res = Acc)
     (checking Loc, std.string.map.add S Loc Acc Res).

pred collect-symbols-clause i:clause, i:A, o:A.
collect-symbols-clause (clause Loc _ C) Acc Res :-
  checking Loc => collect-symbols-term C Acc Res.

pred collect-symbols-program i:list clause, i:A, o:A.
collect-symbols-program [ C | P ] Acc Res :-
  collect-symbols-clause C Acc Acc1,
  collect-symbols-program P Acc1 Res.
collect-symbols-program [] X X.

pred under-env i:A, i:B.

type known term -> prop.

pred similar i:A, i:B.
similar S1 S2 :-
  R is ".*\\." ^ {rex_replace "[\\+\\*]" "." S2},
  rex_match R S1.

pred filter-similar i:A, i:B, o:C.
filter-similar [] _ [].
filter-similar [const K `: _ |KS] S [K|R] :- similar K S, !, filter-similar KS S R.
filter-similar [_|KS] S R :- filter-similar KS S R.

pred str_concat i:list string, o:string.
str_concat [] "".
str_concat [S|SS] R :- str_concat SS RR, R is S ^ " " ^ RR.

pred warn-undeclared i:A, i:B, o:C.
warn-undeclared _Known (pr ( "main") _) ff :- !.
warn-undeclared _ (pr ( S) _) ff :- rex_match ".*\\.aux" S, !.
warn-undeclared _ (pr ( S) _) ff :- rex_match ".*\\.aux\\." S, !.
warn-undeclared Known (pr ( S) LOC) tt :-
  filter-similar Known S Hints,
  if (Hints = []) (H = "") (H is " Did you mean " ^ {str_concat Hints} ^ "?"),
  MSG is "constant " ^ S ^ " has no declared type." ^ H,
  warning LOC MSG.

pred forall_uto10 i:A, i:B, i:C.
forall_uto10 [] _ _ :- !.
forall_uto10 [X|XS] N P :- /*N < 10,*/ !,
  P X Done, !,
  if (Done = tt) (M is N + 1) (M = N),
  forall_uto10 XS M P.
forall_uto10 ([pr _ LOC|_] as L) _ _ :-
  Msg is "[suppressing " ^ {term_to_string {std.length L}} ^ " warnings]",
  warning LOC Msg.
  
pred under-decl-env i:A, i:B.
under-decl-env [] P :- P.
under-decl-env [ X `: PT | XS ] P :-
  %print "Assume" X PT,
  (pi Ty\ of X Ty :- refresh PT Ty) => known X => under-decl-env XS P.

pred under-undecl-env i:list (pair string A), i:prop.
under-undecl-env [] P :- P.
under-undecl-env [ pr X _ | XS ] P :-
  %print "Assume" X PT,
  (of (const X) Ty_ :- !) => under-undecl-env XS P.

pred rm-known i:A, i:B, o:C.
rm-known (const N `: _) S S1 :- std.string.map.remove N S S1.

pred timing i:string, i:prop.
:if "TIME:CHECKER"
timing S P :- !, std.time P Time, print S Time.
timing _ P :- P.

pred check-all-symbols i:std.string.map loc.
:name "check-all-symbols:main"
check-all-symbols _.

pred typecheck-program i:A, i:B, i:C, o:D.
:name "typecheck-program:main"
typecheck-program P Q DeclaredTypes RC :-
  KnownTypes = [
    ((const "pi") `: forall x\ (arrow (arrow x prop) prop)),
    ((const "sigma") `: forall x\ (arrow (arrow x prop) prop)),
    ((const "discard") `: forall x\ x)|DeclaredTypes],
  timing "collect prog" (collect-symbols-program P {std.string.map.empty} TMP),
  collect-symbols-clause Q TMP AllSymbols,
  check-all-symbols AllSymbols,
  std.fold KnownTypes AllSymbols rm-known Unknown,
  std.string.map.bindings Unknown Undeclared,
  forall_uto10 {std.rev Undeclared} 0 (warn-undeclared KnownTypes), !,
  timing "typecheck "
         (under-decl-env {std.rev KnownTypes}
           (under-undecl-env Undeclared
             (typecheck P Q {gettimeofday} {std.length P} RC))).

% ---------- warnings ------------------------------------------------------
% elpi:skip 1
infix >>> 141.

type (>>>) term -> int -> entry.
type variable term -> prop.

pred silence-linear-warning i:string.
silence-linear-warning VN :- rex_match "^_.*" VN ; rex_match ".*_$" VN.

pred report-linear i:A.
report-linear [].
report-linear [(V >>> 1 + uvar) |NS] :- !,
  pp V VN,
  if (not(silence-linear-warning VN))
    (checking LOC,
     MSG is VN ^" is linear: name it _" ^ VN ^
         " (discard) or " ^ VN ^ "_ (fresh variable)",
     warning LOC MSG)
    true,
  report-linear NS.
report-linear [(V >>> uvar) |NS] :-
  pp V VN,
  if (not(silence-linear-warning VN))
    (checking LOC, MSG is VN ^" is unused", warning LOC MSG)
    true,
  report-linear NS.
report-linear [(_ >>> _) | NS] :- report-linear NS.

pred count i:A, i:list B.
count (lam F) E :- pi x\ count (F x) E.
count (app [X|XS]) E :- !, count X E, count (app XS) E.
count (app []) _ :- !.
count X E :- variable X, !, incr X E.
count _ _.

pred incr i:A, i:B.
incr X [(X >>> K) | _] :- add1 K.
incr X [_ | XS] :- incr X XS.

pred add1 i:A.
add1 (uvar as K) :- K = 1 + FRESH_.
add1 (1 + K) :- add1 K.

pred check-non-linear i:A, i:B, i:C.
check-non-linear [N|NS] (arg C) L :- pi x\
 (pp x N :- !) => (variable x) => check-non-linear NS (C x) [(x >>> FRESH_) | L].
check-non-linear [] (arg C) L :- pi x\
 (variable x) => check-non-linear _ (C x) [(x >>> FRESH_) | L].
check-non-linear _ C L :-
  count C L, report-linear L.

pred warn-linear i:A.
:name "warn-linear:main"
warn-linear [].
warn-linear [ (clause Loc Names Clause) |CS] :-
  checking Loc =>  check-non-linear Names Clause [],
  warn-linear CS.

% ---------- test ----------------------------------------------------------

main.

% ------- entry ---------------------------------------

pred type->ppt-clause i:A, i:B, i:C, o:D.
type->ppt-clause S ACC (forall F) (pi C) :- !,
  pi x\ type->ppt-clause S [x|ACC] (F x) (C x).
type->ppt-clause S [] T (pi Str\ ppt T Str :- !, ppt (tconst S) Str).
type->ppt-clause S ACC T (pi Str\ ppt T Str :- !, ppt (tapp [tconst S|Args]) Str) :- std.rev ACC Args.

pred compile-type-abbreviations i:A, o:B.
compile-type-abbreviations [] [].
compile-type-abbreviations [(_ `:= tconst _)|TS] Clauses :- !,
  % we don't refold immediate aliases
  compile-type-abbreviations TS Clauses.
compile-type-abbreviations [(X `:= ctype Y)|TS] Clauses :- not(X = Y), !,
  % we don't refold immediate aliases
  compile-type-abbreviations TS Clauses.
compile-type-abbreviations [(S `:= T)|TS] [Clause|Clauses] :-
  type->ppt-clause S [] T Clause,
  compile-type-abbreviations TS Clauses.

pred pp-var i:term, i:string, o:prop.
pp-var V S R :- var V, !, R = (pi x\ pp x S :- var V, same_term x V, !).

pred get-head-mode i:mode, o:prop.
get-head-mode (mode-fo M) M :- !.
get-head-mode (mode-ho M _) M :- !.

macro @VDASH :- const ":-".
macro @CUT :- const "!".
macro @COMMA :- const ",".
macro @PI :- const "pi".
macro @SIGMA :- const "sigma".
macro @IMPL :- const "=>".
macro @AS :- const "as".

pred head-symbol i:term, o:string.
head-symbol uvar _ :- halt "NYI".
head-symbol (arg Ag) S :- !, pi x\ head-symbol (Ag x) S.
head-symbol (const C) C :- !.
head-symbol (app [@VDASH, X | _]) S :- !, head-symbol X S.
head-symbol (app [@PI, lam B]) S :- !, pi x\ head-symbol (B x) S.
head-symbol (app [const C|_]) C :- !.
head-symbol X Y :- name X, !, std.any->string X Y.
head-symbol A _ :- halt "[head-symbol] uncaught branch" A.

pred head-term i:term, o:term.
head-term (uvar A) (uvar A) :- !.
head-term (arg Ag) S :- !, pi x\ head-term (Ag x) S.
head-term (const C) (const C) :- !.
head-term (app [@VDASH, X | _]) S :- !, head-term X S.
head-term (app [@PI, lam B]) S :- !, pi x\ head-term (B x) S.
head-term (app [const C|_]) (const C) :- !.
head-term X X :- name X, !.
head-term A _ :- halt "[head-term] uncaught branch" A.

pred copy i:term, o:term.
copy N N :- name N, !.
copy (cdata _ as X) X :- !.
copy (app L) (app L'):- !, std.map L copy L'.
copy (lam F) (lam F') :- !, pi x\ copy (F x) (F' x).
copy (const T) (const T) :- !.
copy A A :- var A, !.
copy A _ :- halt "Error in copy" A.

pred fold i:term, i:A, o:A.
fold N A A :- name N, !.
fold (cdata _) A A :- !.
fold (const _) A A :- !.
fold (app L) A A' :- !, 
  std.fold L A fold A'.
fold (lam F) A A' :- !, pi x\ fold (F x) A A'.
fold uvar B B :- !.
fold A _ _ :- halt "Error in fold" A.

pred get-vars i:term, o:list term.
get-vars T L :-
  (pi X L\ fold (uvar as X) L [X|L] :- !) => fold T [] L.



namespace modes {
  pred get-mode i:string, o:modes.
  
  pred load-mode i:pair term modes, o:prop.
  load-mode (pr (const T) M) (get-mode T M :- !).

  pred load-modes i:list (pair term modes), o:list prop.
  load-modes L M :- std.map L load-mode M.

  pred build-mode i:list A, o:list mode.
  build-mode L R :- std.map L (x\r\ r = mode-fo false) R.

  pred get-mode-safe i:term, i:list term, o:modes.
  get-mode-safe uvar Args M :- build-mode Args M, !. 
  get-mode-safe X _    M :- modes.get-mode {head-symbol X} M, !.
  get-mode-safe _ Args M :- build-mode Args M, !. 

}

namespace mode-checking {
  shorten modes.{get-mode-safe}.

  macro @rigid-term :- (const "rigid-term").

  pred loc o:(ctype "Loc.t").
  pred to-constant i:term.
  to-constant V :- V = @rigid-term.

  pred to-rigid-term i:term.
  to-rigid-term T :- (pi x\ copy x _ :-  var x, !, to-constant x) => copy T _.

  pred is-rigid-term i:term.
  to-rigid-term T :- (pi x\ copy x _ :-  var x, !, fail) => copy T _.

  pred set-head-mode i:term, i:list term.
  set-head-mode Head Args :-
    get-mode-safe Head Args Mode, !,
    loc Loc,
    if ({std.length Mode} = {std.length Args}) 
      (std.forall2 Mode Args (m\t\ if (get-head-mode m true) (to-rigid-term t) true)) 
      (print "Invalid mode length for (2)" Head Loc).
  set-head-mode _ _.

  pred get-var-names i:term, o:list string.
  get-var-names N [] :- name N, !.
  get-var-names (cdata _) [] :- !.
  get-var-names (const _) [] :- !.
  get-var-names (app L) L'' :- !, std.map L get-var-names L', std.flatten L' L''.
  get-var-names (lam F) L :- !, pi x\ get-var-names (F x) L.
  get-var-names A [B] :- var A, !, pp A B.
  get-var-names A _ :- halt "Error in get-var-names" A.

  pred check-head-output i:term, i:list term.
  check-head-output Head Args :-
    get-mode-safe Head Args Mode, !, 
    loc Loc, pp Head HeadS,
    std.forall2 Mode Args (m\t\ sigma Vars\
      std.assert! (get-var-names t Vars) "Should not fail",
      if (get-head-mode m true; Vars = []) true (
        print "WARNING: The variables" Vars "are in output position of the predicate\"" HeadS 
          "\"and cannot be ensured to be ground" Loc)).
  check-head-output _ _.

  pred variadic-mode i:term.
  variadic-mode (const "halt").
  variadic-mode (const "print").

  pred is-ho-predicate i:term.
  is-ho-predicate (@rigid-term).

  pred check-args-mode i:term, i:mode, i:term.
  check-args-mode HD Mode Arg :-
    get-head-mode Mode true, 
    get-var-names Arg L, not (L = []), !,
    print "WARNING: Not ground" {pp Arg} "passed to" {pp HD} {loc}.
  % TODO: following rule aims to go under lambda which are args of a predicate
  %       however, this is gives a error if partial application is used
  % check-args-mode _ Loc Mode Arg :-
  %   Mode, Arg = lam L, !,
  %   print ("Going under lambda") Arg,
  %   pi x\ std.assert!(check-well-moded-negative Loc (L x)) "Should not fail".
  check-args-mode _ Mode _   :- get-head-mode Mode true, !.
  check-args-mode _ Mode Arg :- get-head-mode Mode false, to-rigid-term Arg.

  pred check-well-moded-negative i:term.
  check-well-moded-negative N :- name N, !.
  check-well-moded-negative (cdata _) :- !.
  check-well-moded-negative (const _) :- !.
  check-well-moded-negative (app [@COMMA | L]) :- !,
    loc Loc,
    std.forall L (x\ 
      if (var x) 
        (print "WARNING: Passed flexible to ," Loc) 
        (check-well-moded-negative x)).
  check-well-moded-negative (app [@PI, lam B]) :- !,
    pi x\ check-well-moded-negative (B x).
  check-well-moded-negative (app [@IMPL, Hyp, Body]) :- !,
    check-well-moded-positive Hyp [],
    check-well-moded-negative Body.
  check-well-moded-negative (app [HD|_]) :- variadic-mode HD, !.
  check-well-moded-negative (app [HD|Args]) :- !,
    if (var HD) (print "WARNING: Flex head symbol" HD "at" {loc}) true,
    get-mode-safe HD Args Mode,
    if ({std.length Mode} = {std.length Args}) 
      (std.forall2 Mode Args (x\y\std.assert!(check-args-mode HD x y) "Mh")) 
      (print "Invalid mode length for" HD {loc}).
  check-well-moded-negative (lam F) :- !, 
    pi x\ check-well-moded-negative (F x).

  pred check-well-moded-negative-list i:list term.
  check-well-moded-negative-list [] :- !.
  check-well-moded-negative-list [X | Xs] :-
    check-well-moded-negative X,
    check-well-moded-negative-list Xs.

  pred to-check i:string.
  to-check _ :- false, !.

  pred check-well-moded-positive-ho-mode i:list term, i:list mode, i:list term.
  check-well-moded-positive-ho-mode [A|As] [mode-fo X|Ms] Prem :- !,
    if X (to-rigid-term A) true, 
    check-well-moded-positive-ho-mode As Ms Prem.
  check-well-moded-positive-ho-mode [A|As] [mode-ho true M|Ms] Prem :- var A, !,
    pi x\ (pi X\ copy X x :- same_term X A, !) => std.map Prem copy (Prem' x), !, 
    head-symbol x HS,
    modes.get-mode HS M =>
    check-well-moded-positive-ho-mode As Ms (Prem' x).
  check-well-moded-positive-ho-mode [_|As] [_|Ms] Prem :- !,
    check-well-moded-positive-ho-mode As Ms Prem.
  check-well-moded-positive-ho-mode [] [] Prem :- check-well-moded-negative-list Prem.

  pred check-well-moded-positive i:term, i:list string.
  check-well-moded-positive uvar _ :- !, 
    print "WARNING: Got uvar in check well-moded-positive" {loc}.
  check-well-moded-positive (arg B) [N|Names] :- !,
    pp-var X N P, P => check-well-moded-positive (B X) Names.
  check-well-moded-positive (const _) _ :- !.
  check-well-moded-positive (app [@VDASH, (app [Head | Args]) | Prem]) Names_ :-
    check-well-moded-positive-ho-mode Args {get-mode-safe Head Args} Prem,
    check-head-output Head Args.
  check-well-moded-positive (app [@VDASH, (const _) | Prem]) Names_ :- !,
    check-well-moded-negative-list Prem.
  check-well-moded-positive (app [@PI, lam B]) Names :- !,
    check-well-moded-positive (B FRESH_) Names.
  check-well-moded-positive (app [@COMMA | L]) Names :- !,
    std.forall L (x\ check-well-moded-positive x Names).
  check-well-moded-positive (app ([const "::", A, L])) Names :- !,
    check-well-moded-positive A Names,
    check-well-moded-positive L Names.
  check-well-moded-positive (app _ as App) Names :- !, 
    check-well-moded-positive (app [@VDASH, App]) Names.
  check-well-moded-positive A _ :- 
    halt "[check-well-moded-positive] uncaught branch" A.

  pred check-well-moded-prog i:A.
  check-well-moded-prog [] :- !.
  check-well-moded-prog [clause Loc Vars Body | Tl] :- 
    to-check {head-symbol Body}, !,
    loc Loc => check-well-moded-positive Body Vars,
    check-well-moded-prog Tl.
  check-well-moded-prog [_ | Tl] :- 
    check-well-moded-prog Tl.
}


pred mem= i:list A, i:A.
mem= [A|_] B :- same_term A B, !.
mem= [_|A] B :- mem= A B.

namespace functionality {
  shorten modes.{get-mode-safe}.

  macro @not-func :- functionality nfpred [].
  macro @not-funct :- functionality npred [].
  macro @preserve-func :- functionality _ [].

  % Add the name of functional predicates by hand
  pred is-functional i:term, o:list functionality.
  is-functional (const "=") [@preserve-func, @preserve-func].
  is-functional (const "trace.counter") [@not-func, @not-func].
  is-functional (const "debug-print") [@not-func, @not-func].
  is-functional (const "not") [@not-func].
  is-functional (const "is") [@preserve-func, @preserve-func].
  is-functional (const "calc") [@preserve-func, @preserve-func].

  pred is-functional-variadic i:string.
  is-functional-variadic "halt".
  is-functional-variadic "print".

  pred current-pred o:string.

  pred pred-map i:string, o:clause.

  pred loc1 o:(ctype "Loc.t"). 
  pred loc2 o:(ctype "Loc.t"). 

  % A variable [v I B] has the identifier I (a unique integer),
  % The boolean B allows to know if I can be functionally determined by the 
  % clause
  type v int -> bool -> functionality -> term. 

  { % ERRORS MSG
    pred error-non-functional-head i:term.
    error-non-functional-head T :-
      halt "The head of" {pp T} "contains a potentially non functional argument" {loc1}.

    pred error-non-functional-prop.
    error-non-functional-prop :-
      halt "There is a call to a non functional variable in the body of" {current-pred} {loc1}.

    pred error-func-atom-non-func-arg.
    error-func-atom-non-func-arg :- 
     halt "Non coherent functionality setting" {loc1}.
  }

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%% AUXILIARY FUNCTIONS %%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  { % AUX
    pred rev_map i:list A, i:(pred i:A, o:B), o:list B.
    rev_map L F R :- rev_map.aux L F [] R.
    
    pred rev_map.aux i:list A, i:(pred i:A, o:B), i:list B, o:list B.
    rev_map.aux [] _ L L.
    rev_map.aux [A|As] F L L' :- F A B, !, rev_map.aux As F [B|L] L'.

    pred load-functional-prop i:(pair term (list functionality)), o:prop.
    load-functional-prop (pr (const P) L) (is-functional (const P) L) :- !.
    load-functional-prop A _ :- halt "Only const can be passed to pred load_functional_prop. Received" A.

    pred load-functional-props i:list (pair term (list functionality)), o:list prop.
    load-functional-props L S :- std.map L load-functional-prop S.

    pred normalize-term.aux i:term, o:term.
    normalize-term.aux (app [@VDASH | _] as A) A :- !.
    normalize-term.aux (const _ as A) (app [@VDASH, A]) :- !.
    normalize-term.aux (app _ as A) (app [@VDASH, A]) :- !.
    normalize-term.aux A _ :- halt "[normalize-term.aux] Unexpected branch" A.

    pred flatten-commas i:list term, o:list term. % STOP HERE
    flatten-commas [] [].
    flatten-commas [app[@COMMA|L]|TL] R :- !,
      flatten-commas L L1,
      flatten-commas TL L2,
      std.append L1 L2 R.
    flatten-commas [A|As] [A|As'] :- !, flatten-commas As As'.

    pred normalize-term i:term, o:term, o:list term.
    normalize-term A HD TL' :-
      std.assert!(normalize-term.aux A (app [@VDASH, HD | TL])) "[normalize-term] fail1",
      std.assert!(flatten-commas TL TL') "[normalize-term] fail2".

    pred build-pred-map i:pair string (list clause), o:list prop.
    build-pred-map (pr _ []) [].
    build-pred-map (pr A [X|Xs]) [pred-map A X|L] :- build-pred-map (pr A Xs) L.

    pred program2pred_buckets i:list clause, i:std.string.map (list clause), o:list prop, o:list (list clause).
    program2pred_buckets [] B C D :- 
      std.string.map.bindings B L', 
      std.map L' build-pred-map C', std.flatten C' C,
      std.map L' (x\r\ sigma A B Br\ x = pr A B, std.rev B Br, r = pr A Br) L,
      std.map L snd D.
    program2pred_buckets [Cl|As] B C D :-
      Cl = clause _ _ A,
      head-symbol A K, is-functional (const K) _, !,
      (std.string.map.find K B V; V = []), !,
      std.string.map.add K [Cl|V] B B1,
      program2pred_buckets As B1 C D.
    program2pred_buckets [_|As] B C D :- program2pred_buckets As B C D.

    pred go-under-arg.aux i:list string, i:term, i:(pred i:term, i:list term).
    go-under-arg.aux [N|Ns]  (arg B) F :- !,
      pp-var Fresh N PP,
      PP => go-under-arg.aux Ns (B Fresh) F.
    go-under-arg.aux _  (app [@PI, lam B]) F :- !, 
      go-under-arg.aux [] (B Fresh_) F.
    go-under-arg.aux []      T       F :- !, 
      std.assert!(normalize-term T HD TL) "[normalize-term] should not fail", !,
      F HD TL.
    go-under-arg.aux A B _ :- halt "[go-under-arg.aux] should not fail..." A B.

    pred go-under-term i:term, i:(pred i:term, i:list term).
    go-under-term A F :- go-under-arg.aux [] A F. 

    pred go-under-arg i:(pred o:A), i:clause, i:(pred i:term, i:list term).
    go-under-arg LocP (clause Loc Names T) Cont :-
      (LocP Loc :- !) => go-under-arg.aux Names T Cont.

    pred newv i:term.
    newv T :- new_int Z, T = (v Z FunctionalDetermined_ Functionality_).
    
    pred var2v i:term.
    var2v T :- (pi X Y Z\ copy (uvar as X) _ :- !, newv X) => copy T _.
  }

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%% CHECK OVERLAPPING HEADS %%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  pred same-as i:term, i:term.
  same-as A B :- A = B, !.
  same-as A B :- halt "Found two non unifying terms" {pp A} "and" {pp B} "with same `as` variable".

  { % OVERLAP CHECK
    pred overlapping-terms i:term, i:term.
    overlapping-terms (app[@AS,L,R]) T :- !, same-as L R, overlapping-terms R T. 
    overlapping-terms T (app[@AS,L,R]) :- !, same-as L R, overlapping-terms T R. 
    overlapping-terms (lam X) (lam Y) :- !, pi x\ overlapping-terms (X x) (Y x).
    overlapping-terms (lam X) T :- !, pi x\ overlapping-terms (X x) T.
    overlapping-terms X (lam T) :- !, pi x\ overlapping-terms X (T x).
    overlapping-terms uvar _ :- !.
    overlapping-terms _ uvar :- !.
    overlapping-terms X X :- name X.
    overlapping-terms (app [uvar|Sc] as T1) T :- !, print"Uvar left" T1 T, prune V Sc, V = T.
    overlapping-terms T (app [uvar|Sc]) :- !, print"Uvar right", prune V Sc, V = T.
    overlapping-terms (app X) (app Y) :- !, std.forall2 X Y overlapping-terms.
    overlapping-terms (const X) (const X) :- !.
    overlapping-terms (cdata X) (cdata X) :- !.

    pred overlapping-head.aux i:modes, i:list term, i:list term.
    overlapping-head.aux [] [] [].
    overlapping-head.aux [M|Ms] [A|As] [B|Bs]  :- get-head-mode M true, !,
      overlapping-terms A B, overlapping-head.aux Ms As Bs.
    overlapping-head.aux [_|Ms] [_|As] [_|Bs] :- overlapping-head.aux Ms As Bs.

    pred overlapping-head i:term, i:term. % Takes 2 heads
    overlapping-head (app[A|As]) (app[B|Bs]) :- !,
      head-symbol A Ahs, head-symbol B Bhs, Ahs = Bhs, !,
      get-mode-safe A As M,
      overlapping-head.aux M As Bs, !.
    overlapping-head A B :- halt "[overlapping-head] uncaught branch" A B.

    pred cut-in-antecedent i:list term. % Takes the body
    cut-in-antecedent L :- mem= L @CUT, !.

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%% CHECK FUNCTIONAL BODY %%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % [partition-cut L A B] if L = [p1, ..., pm, !, pn, ..., po] then
    %                          A = [p1, ..., pm] and B = [pn, ..., po]
    pred partition-cut i:list term, o:list term, o:list term.
    partition-cut [] [] [] :- !.
    partition-cut [@CUT|L] [] L :- !.
    partition-cut [A|B] [A|As] Bs :- partition-cut B As Bs. 

    pred split-functional-ctx i:list term, o:list term, o:list term.
    split-functional-ctx L Bef Aft :- 
      partition-cut {std.rev L} A B,
      std.rev B Bef, std.rev A Aft, !.
    split-functional-ctx _ _ _ :- halt "[split-functional-ctx] should not fail...".
  }

  %%
  %% FUNCTIONAL BODY
  %%
  { % FUNCTIONAL BODY
    namespace old1 {
      /* Here we check that all the premise of the body are functional
      * and that all hyps do not break functionality
      */
      % THIS IS UNUSED, IN FAVOUR OF functional-dependecies
      pred functional-premise i:term.
      % BASE CASES
      functional-premise (cdata _) :- !.
      functional-premise (const _) :- !.
      functional-premise (uvar) :- halt "[functional-premise] found uvar..." {loc1}.
      % APP CASES
      functional-premise (app [@PI, lam B]) :- !, pi x\ functional-premise (B x).
      functional-premise (app [@SIGMA, lam B]) :- !, functional-premise (B X_).
      functional-premise (app [@IMPL, Hyp | Body]) :-
        head-symbol Hyp HypH, is-functional (const HypH) _, !,
        % here the hyp is declared functional, then we check it for functionality 
        Clause = clause {loc1} [] Hyp,
        std.findall (pred-map HypH _) ClausesL,
        std.map ClausesL (x\r\ pred-map _ r = x) Clauses,
        pred-map HypH Clause =>  (
          check-functionality-clause-clauses Clause Clauses,
          std.forall Body functional-premise).
      functional-premise (app [@IMPL, Hyp_ | Body]) :- !, % Hyp_ is not declared functional: ignore it
        std.forall Body functional-premise.
      functional-premise (app [@COMMA|L]) :- !, std.forall L functional-premise.
      functional-premise (app [const C | _]) :- % The premise is functional
        is-functional (const C) _L, !. % TODO: take into account _L...
      functional-premise (app [(const _ as H) | L]) :- % The premise mode are all input
        std.forall {get-mode-safe H L} (x\ get-head-mode x true), !.
      functional-premise A :- halt "[functional-premise] uncaught branch" A {loc1}.

      pred functional-body i:list term.
      % ALL PREMISES AFTER THE LAST CUT SHOULD BE FUNCTIONAL
      functional-body L :- % PROPOSITION 3.4
        split-functional-ctx L Bef_ Aft, 
        std.forall Aft functional-premise.
    }

    namespace old2 {
      type func bool -> term.

      pred all-funct.

      pred set-var-functional-output i:mode, i:term.
      set-var-functional-output M T :- get-head-mode M false, !, % The output mode set T to functional
        (pi X\ copy (uvar as X) _ :- !, X = func tt) =>
        (pi X\ copy (func X) _ :- !, X = tt) => copy T _.
      set-var-functional-output _ _.

      pred set-vars-non-functional i:term.
      set-vars-non-functional T :-
        (pi X Y\ copy (uvar as X) _ :- !, X = func Y) => copy T _.

      pred functional-dependencies i:term. 
        /* THIS CHECK CLAUSES BEFORE AND AFTER BANG
        * enhancement of previous functional-premises
        * in particular if a atom is functional, its output are set to functional, too.
        * if the atom is not functional the output are set to maybe-functional
        * a clause is functional if all of its output position are set to functional
        * or are flexible
        * However, this assumption is no more true in this case:
        *   i o      o    i o
        * f X Y :- q Y, r X Y. 
        * Where: f and r are functional
        * The problem comes out if we have the query
        * (pi X\ r X X) => q 1 => q 2 => q Y, f X Y.
        * It is not true that Y is functionally determined by f
        */
      % BASE CASES
      functional-dependencies (cdata _) :- !.
      functional-dependencies (const _) :- !.
      functional-dependencies (func  _) :- !.
      functional-dependencies (uvar) :- halt "[functional-dependencies] found uvar..." {loc1}.
      % APP CASES
      functional-dependencies (app [@PI, lam B]) :- !, pi x\ functional-dependencies (B x).
      functional-dependencies (app [@SIGMA, lam B]) :- !, functional-dependencies (B X_).
      functional-dependencies (app [@IMPL, Hyp | Body]) :- % Hyp if functional
        head-symbol Hyp HypH, is-functional (const HypH) _, !,
        % here the hyp is declared functional, then we check it for functionality 
        Clause = clause {loc1} [] Hyp,
        std.findall (pred-map HypH _) ClausesL,
        std.map ClausesL (x\r\ pred-map _ r = x) Clauses,
        pred-map HypH Clause =>  (
          check-functionality-clause-clauses Clause Clauses,
          std.forall Body functional-dependencies).
      functional-dependencies (app [@IMPL, Hyp_ | Body]) :- !, % Hyp_ is not declared functional: ignore it
        std.forall Body functional-dependencies.
      functional-dependencies (app [@COMMA|L]) :- !, std.forall L functional-dependencies.
      functional-dependencies (app [(const Cs as C) | L]) :- % The premise is functional
        (all-funct; is-functional (const Cs) _FL), !, % TODO: _FL should be taken into account
        std.forall2 {get-mode-safe C L} L set-var-functional-output.
      functional-dependencies (app [(const _) | L]) :- !, % The premise is not functional
        std.forall L set-vars-non-functional.
      functional-dependencies A :- halt "[functional-dependencies] uncaught branch" A {loc1}.

      pred head-is-functional i:term.
      head-is-functional T :- 
        (copy (func uvar) _ :- !, fail) => 
        (copy (func ff) _ :- !, fail) => copy T _.

      pred functional-body i:term, i:list term.
      functional-body H L :- % PROPOSITION 3.4
        split-functional-ctx L Bef Aft,
        head-symbol H HS,
        all-funct => std.forall Bef functional-dependencies,
        current-pred HS => std.forall Aft functional-dependencies,
        not(head-is-functional H),
        error-non-functional-head H.
      functional-body _ _.
    }

    { % USING CONSTRAINTS
      pred progress-func-term i:term, i:list bool.
      progress-func-term T_ L :- 
        std.spy(std.exists! L (x\ not (var x), x = ff)), !,
        std.forall L (x\ x = ff).
      progress-func-term T L :- 
        declare_constraint (progress-func-term T L) L.

      % constraint {

      % }

      pred set-non-functional i:term.
      set-non-functional T :- 
        set-vars-non-functional-hard T.

      pred suspend-functional-term i:term.
      suspend-functional-term T :- 
        print "Suspending" {pp T},
        (pi X L\ fold (v _ (uvar as X) _) L [X|L] :- !) => fold T [] VL,
        declare_constraint (progress-func-term T VL) VL.

      pred is-functional-call-arg i:term, i:functionality.
      is-functional-call-arg A B :- print "Hello" A "FUNCTIONALITY IS" B, fail.
      is-functional-call-arg (const _) _ :- !.
      is-functional-call-arg (v X _ F) F' :- not (F = F'),
        halt "Variable" X "has been set with functionality" F "and cannot be set to functionality" F'.
      is-functional-call-arg (v _ _ F) F :- !.
      is-functional-call-arg (app [const _ | L]) (functionality fpred LF) :- 
        std.length L Len1, std.length LF Len2, Len1 = Len2, !,
        std.spy(is-functional-call-list L LF).
      is-functional-call-arg (app [(const _ as H) | L]) (functionality fpred _) :- !,
        is-functional H LF,
        is-functional-call-list L LF.
      is-functional-call-arg (app[(v X _ F)|_]) F' :- not(F = F'),
        halt "Variable" X "has been set with functionality" F "and cannot be set to functionality" F.
      is-functional-call-arg (app[(v _ _ F)|L]) ((functionality fpred FL) as F) :- 
        is-functional-call-list L FL.
      is-functional-call-arg _ (functionality _ _) :- !.

      pred is-functional-call-list i:list term, i:list functionality.
      is-functional-call-list [] [].
      is-functional-call-list [app[Hd|Args] | Xs] [] :- !,
        is-functional Hd FL,
        is-functional-call-list Args FL,
        is-functional-call-list Xs [].
      is-functional-call-list [A|B] [C|D] :-
        is-functional-call-arg A C,
        is-functional-call-list B D.

      pred is-functional-call i:term.
      is-functional-call (app [HD|Args]) :- 
        is-functional HD L, !, 
        print "----------------------------",
        print "args list [" {pp-list Args} "] mode list" L "bb",
        is-functional-call-list Args L.
      is-functional-call (app [const C|_]) :- is-functional-variadic C, !.
      is-functional-call (app [v _ _ (functionality _ F) | L]) :-
        is-functional-call-list L F.

      pred loop-functional-premise-term i:term.
      loop-functional-premise-term (app [@PI, lam B]) :- !, pi x\ loop-functional-premise-term (B x).
      loop-functional-premise-term (app [@SIGMA, lam B]) :- !, loop-functional-premise-term (B X_).
      loop-functional-premise-term (app [@IMPL, Hyp_ | Body]) :- !, std.forall Body loop-functional-premise-term.
      loop-functional-premise-term (app [@COMMA|L]) :- !,  std.forall L loop-functional-premise-term.
      loop-functional-premise-term (app [const _ | _] as T) :-
        print "AA",
        std.spy(is-functional-call T), !, suspend-functional-term T.
      loop-functional-premise-term (app [(v _ _ _) | _] as T) :- !,
        print "MH",
        std.spy!(is-functional-call T), !. 
      loop-functional-premise-term _.


      pred loop-functional-premise i:list term.
      loop-functional-premise [].
      loop-functional-premise [X|Xs] :-
        std.ignore-failure! (loop-functional-premise-term X),
        loop-functional-premise Xs.

      pred loop-non-functional-premise-term i:term.
      loop-non-functional-premise-term (v _ uvar _ as V) :- is-functional V _, !.
      loop-non-functional-premise-term (v _ tt _ as V) :- is-functional V _, !.
      loop-non-functional-premise-term (v _ _ _) :- !, error-non-functional-prop.
      loop-non-functional-premise-term (const _) :- !.
      % APP CASES
      loop-non-functional-premise-term (app [@PI, lam B]) :- !, pi x\ loop-non-functional-premise-term (B x).
      loop-non-functional-premise-term (app [@SIGMA, lam B]) :- !, loop-non-functional-premise-term (B X_).
      loop-non-functional-premise-term (app [@IMPL, Hyp | Body]) :- % Hyp if functional
        head-symbol Hyp HypH, is-functional (const HypH) _, !,
        % here the hyp is declared functional, then we check it for functionality 
        Clause = clause {loc1} [] Hyp,
        std.findall (pred-map HypH _) ClausesL,
        std.map ClausesL (x\r\ pred-map _ r = x) Clauses,
        pred-map HypH Clause =>  (
          check-functionality-clause-clauses Clause Clauses,
          std.forall Body loop-non-functional-premise-term).
      loop-non-functional-premise-term (app [@IMPL, Hyp_ | Body]) :- !, % Hyp_ is not declared functional: ignore it
        std.forall Body loop-non-functional-premise-term.
      loop-non-functional-premise-term (app [@COMMA|L]) :- !, std.forall L loop-non-functional-premise-term.

      loop-non-functional-premise-term (app [const _ | _] as T) :-
        not (is-functional-call T), !, set-vars-non-functional-hard T.
      loop-non-functional-premise-term (app [(v _ _ _) | _] as T) :- !, % The variable is functional
        not (is-functional-call T), !, set-vars-non-functional-hard T.
      loop-non-functional-premise-term _ :- !.

      loop-non-functional-premise-term A :- halt "[loop-non-functional-premise-term] uncaught branch" A {loc1}.

      pred loop-non-functional-premise i:list term.
      loop-non-functional-premise [].
      loop-non-functional-premise [X|Xs] :-
        loop-non-functional-premise-term X,
        loop-non-functional-premise Xs.

      pred loop-premise i:list term.
      % loop-premise [].
      % loop-premise [X|Xs] :-
      %   head-term X H, is-functional H _, !,
      %   suspend-functional-term X,
      %   loop-premise Xs.
      % loop-premise [X|Xs] :-
      %   set-non-functional X, !,
      %   loop-premise Xs.
      loop-premise L :-
        print "ENTERING LOOP FUNCTIONAL PREMISE",
        loop-functional-premise L,
        print "EXITING LOOP FUNCTIONAL PREMISE",
        print L,
        loop-non-functional-premise L,
        print L.

    }

    { % OLD FUNCTIONALITY
      pred set-var-functional-all i:term.
      set-var-functional-all T :-
        (pi X\ copy (v _ ff _) _ :- error-func-atom-non-func-arg) =>
        (pi X\ copy (v _ X _) _ :- X = tt, !) => copy T _.

      pred set-vars-non-functional-hard i:term.
      set-vars-non-functional-hard T :-
        (pi X\ copy (v _ tt _) _ :- error-func-atom-non-func-arg) =>
        (pi X\ copy (v _ X _) _ :- X = ff) => copy T _.

      pred functional-dependencies1 i:term.
      % BASE CASES
      functional-dependencies1 (cdata _) :- !.
      functional-dependencies1 (const _) :- !.
      
      % here some non-functional atom has set the variable non being uniquely 
      % determined
      functional-dependencies1 (v _ ff _) :- !, error-non-functional-prop.

      /* here the variable is functional and uniquely determined
      * for example, :functional pred do i:(:functional pred).
      *              do X :- X.
      */ 
      functional-dependencies1 (v _ _ _ as V) :- is-functional V _, !.
      functional-dependencies1 (v _ _ _) :- !, error-non-functional-prop.
      functional-dependencies1 (uvar) :- print "[functional-dependencies1] WARNING found uvar..." {loc1}.
      % APP CASES
      functional-dependencies1 (app [@PI, lam B]) :- !, pi x\ functional-dependencies1 (B x).
      functional-dependencies1 (app [@SIGMA, lam B]) :- !, functional-dependencies1 (B X_).
      functional-dependencies1 (app [@IMPL, Hyp | Body]) :- % Hyp if functional
        head-symbol Hyp HypH, is-functional (const HypH) _, !,
        % here the hyp is declared functional, then we check it for functionality 
        Clause = clause {loc1} [] Hyp,
        std.findall (pred-map HypH _) ClausesL,
        std.map ClausesL (x\r\ pred-map _ r = x) Clauses,
        pred-map HypH Clause =>  (
          check-functionality-clause-clauses Clause Clauses,
          std.forall Body functional-dependencies1).
      functional-dependencies1 (app [@IMPL, Hyp_ | Body]) :- !, % Hyp_ is not declared functional: ignore it
        std.forall Body functional-dependencies1.
      functional-dependencies1 (app [@COMMA|L]) :- !, std.forall L functional-dependencies1.

      functional-dependencies1 (app [const C | L]) :- % The premise is functional
        if (C = "do") (print "AAAA") true,
        is-functional (const C) F, !, 
        if (C = "do") (print F "L:" L ) true,
        % TODO: forall i in L, functionality i = _F[i]
        std.forall L set-var-functional-all.
      functional-dependencies1 (app [(v _ _ _ as V) | L]) :- !, % The variable is functional
        is-functional V _F, !, 
        % TODO: forall i in L, functionality i = _F[i]
        std.forall L set-var-functional-all. 
      functional-dependencies1 (app [const C | _]) :- % The premise is variadic
        is-functional-variadic C, !.
        
      
      functional-dependencies1 (app [const _ | L]) :- !,
        std.forall L set-vars-non-functional-hard.
      functional-dependencies1 (app [v _ _ _ | L]) :- !,
        std.forall L set-vars-non-functional-hard.
      
      functional-dependencies1 A :- halt "[functional-dependencies1] uncaught branch" A {loc1}.

      pred head-is-functional i:term.
      head-is-functional T :- (copy (v _ ff _) _ :- !, fail) => copy T _.

      pred add-functional-arguments-list i:list term, i:list functionality, o:list prop.
      add-functional-arguments-list [] [] [].
      add-functional-arguments-list [_ | L] [@not-func | FL] R :- !,
        add-functional-arguments-list L FL R.
      add-functional-arguments-list [_ | L] [functionality npred _ | FL] R :- !,
        add-functional-arguments-list L FL R.
      add-functional-arguments-list [const "discard" | L] [_ | FL] R :- !,
        add-functional-arguments-list L FL R.
      add-functional-arguments-list [(v T _ _) | L] [functionality _ F | FL] [(pi x\ is-functional (v T x _) F) | R] :- !,
        add-functional-arguments-list L FL R.
      add-functional-arguments-list [T|_] [F|_] _ :- 
        halt "[add-functional-arguments-list] uncaught branch" T F {loc1}.

      pred add-functional-arguments i:term, o:list prop.
      add-functional-arguments (const _) [] :- !.
      add-functional-arguments (app [const C|L]) R :- is-functional (const C) LF, !,
        add-functional-arguments-list L LF R.
      add-functional-arguments (app [const _|_]) [].

      pred forall-spy i:bool, i:list A, i:A -> prop.
      forall-spy _ [] _.
      forall-spy tt [A|As] P :- std.spy! (P A), forall-spy tt As P.
      forall-spy ff [A|As] P :- P A, forall-spy ff As P.
    }

    pred functional-body i:term, i:list term.
    % functional-body H L :- % PROPOSITION 3.4
    %   split-functional-ctx L Bef_ Aft,
    %   T = (app [@VDASH, H|L]),
    %   % print {pp T},
    %   var2v T,
    %   % print {pp T},
    %   add-functional-arguments H FuncArgs,
    %   head-symbol H HS,
    %   % print {pp T},
    %   FuncArgs => current-pred HS => 
    %     forall-spy ff Aft functional-dependencies1,
    %   not(head-is-functional H),
    %   error-non-functional-head H.
    % functional-body _ _.
    functional-body Hd Args :-
      T = (app [@VDASH, Hd|Args]),
      var2v T,
      split-functional-ctx Args Bef_ Aft,
      print "Working with" {pp T},
      print "After is" Aft,
      add-functional-arguments Hd FuncArgs,
      head-symbol Hd HS,
      FuncArgs => current-pred HS => 
        (pi X\ head-term (v _ _ _ as X) X :- !) => 
          std.spy!(loop-premise Aft),
      not(head-is-functional Hd),
      error-non-functional-head Hd.
    functional-body _ _.
  }

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%% MAIN %%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  { % Check functionality main
    pred check-functionality-term-term i:term, i:list term, i:term, i:list term.
    check-functionality-term-term AH _ BH _ :-
      overlapping-head AH BH,
      halt "Clause" {pp AH} "overlaps with" 
                    {pp BH} "at" {loc1} "and" {loc2}.

    pred check-functionality-term-clauses i:term, i:list term, i:list clause.
    check-functionality-term-clauses _ _ [].
    check-functionality-term-clauses A ABo [Clause|_] :- % PROPOSITION 3.7
      go-under-arg loc2 Clause (check-functionality-term-term A ABo).
    check-functionality-term-clauses A ABo [_|Bs] :-
      check-functionality-term-clauses A ABo Bs. 

    pred check-functionality-clauses-term i:list clause, i:term, i:list term.
    check-functionality-clauses-term Clauses HD TL :-
      Msg is ("Body of " ^ {pp HD} ^ ":-" ^ {pp-list TL} ^ " is not functional"),
      std.assert! (functional-body HD TL) Msg,
      if (cut-in-antecedent TL) % PROPOSITION 3.6
          true
          (check-functionality-term-clauses HD TL Clauses).
    
    pred check-functionality-clause-clauses i:clause, i:list clause.
    check-functionality-clause-clauses Clause Clauses :-
      go-under-arg loc1 Clause (check-functionality-clauses-term Clauses).

    pred check-functionality-list i:list clause.
    check-functionality-list [].
    check-functionality-list [Clause|Clauses] :-
      check-functionality-clause-clauses Clause Clauses,
      check-functionality-list Clauses. 

    pred check-functionality i:list clause.
    check-functionality Program :-
      program2pred_buckets Program {std.string.map.empty} ProgramProps ProgramClauses,
      (pi x\ copy (old2.func _ as x) x :- !) =>
      (pi A\ fold (v _ _ _) A A :- !) =>
      (pi x\ copy (v _ _ _ as x) x :- !) =>
      (pi B\ pp (v _ ff _) "non-func" :- !) =>
        ProgramProps => std.forall ProgramClauses check-functionality-list.
  }
}

pred check i:A, i:B, i:C, i:D, i:E, i:F.
:name "check:main"
check P Q DeclaredTypes TypeAbbreviations Modes FuncPred :-
  % print FuncPred,
  compile-type-abbreviations TypeAbbreviations Abbrevs,
  Abbrevs => typecheck-program P Q DeclaredTypes RC, !,
  warn-linear P, !,
  if (var RC) (true) (fail),
  modes.load-modes Modes ModesP,
  functionality.load-functional-props FuncPred FuncP,
  ModesP => FuncP => (
    functionality.check-functionality P,
    mode-checking.check-well-moded-prog P),
  true
  .

% vim: set ft=lprolog:
