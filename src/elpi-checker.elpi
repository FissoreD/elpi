/* elpi: embedded lambda prolog interpreter                                  */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

% --------- HOAS or programs  ------------------------------------------------

kind typ type. %%%%% types %%%%%%

type arrow typ -> typ -> typ.
type tconst string -> typ.
type tapp list typ -> typ.
type prop typ.
type forall (typ -> typ) -> typ. % polymorphic type declarations
type ctype string -> typ.

% --------- utils  ---------------------------------------------------------

type (`:) term -> typ -> entry.
type (`:=) string -> typ -> entry.

% --------- error reporting  ------------------------------------------------
kind err type.
type type-err term -> typ -> typ -> err.
type wrong-arity term -> typ -> list term -> err.
type unknown term -> err.
type assert prop -> err -> prop.

type error list (pair (ctype "Loc.t") string) -> bool -> prop.
mode (error i o).

:name "default-typechecking-error"
error Msg tt :- std.forall Msg (x\ sigma L M\ fst x L, snd x M, print L "Error:" M).

mode (warning i i).
type warning (ctype "Loc.t") -> string -> prop.
:name "default-typechecking-warning"
warning Loc Msg :- print Loc "Warning:" Msg.

mode (assert i i).
assert P _ :- P, !.
assert _ (type-err T Ty ETy) :- !,
  checking LOC,
  ppt Ty TyPP, ppt ETy ETyPP,
  if (TyPP = ETyPP) (term_to_string Ty TyS, term_to_string ETy ETyS) (TyS = TyPP, ETyS = ETyPP),
  MSG is {pp T} ^ " has type " ^ TyS ^
         " but is used with type " ^ ETyS,
  error [pr LOC MSG] _.
assert _ (wrong-arity T Ty A) :- !,
  checking LOC,
  MSG is {pp T} ^ " has type " ^ {ppt Ty} ^
          " but is applied to " ^ {pp-list A},
  error [pr LOC MSG] _.

mode (stash-new i i).
stash-new E S :- open_safe E L, ( std.mem! L S ; stash_in_safe E S ), !.

report-all-failures-if-no-success P RC :-
  new_safe E,
  (((pi ML\ error ML _ :- !, std.forall ML (stash-new E), fail) => P)
   ;
   (error {open_safe E} RC)).
report-all-failures-and-fail-if-no-success P RC :-
  new_safe E,
  (((pi ML\ error ML _ :- !, std.forall ML (stash-new E), fail) => P)
   ;
   (error {open_safe E} RC, fail)).

mode (pp i o).
type pp term -> string -> prop.
pp (app L) T1 :- !, pp-list L T, T1 is "(" ^ T ^ ")".
pp (lam F) T :- !, pi x\ term_to_string x XS, (pp x XS :- !) => pp (F x) T.
pp (const "discard") "_" :- !.
pp (const S) S :- !.
pp (cdata X) S :- !, term_to_string X S.
pp X XS :- term_to_string X XS.

mode (pp-list i o).
pp-list [X] Y :- !, pp X Y.
pp-list [X|XS] Y :- pp-list XS XSS, pp X XT, Y is XT ^ " " ^ XSS.
pp-list [] "".

mode (ppt i o).
ppt (ctype S) X :- !, X is "(ctype " ^ S ^ ")".
ppt (tconst X) X :- !.
ppt (tapp L) X :- !, ppt-list L T, X is "(" ^ T ^ ")".
ppt (arrow A B) S :- !, ppt A AS, ppt B BS, S is "(" ^ AS ^ " -> " ^ BS ^ ")".
ppt X Y :- term_to_string X Y.

mode (ppt-list i o).
ppt-list [X] Y :- !, ppt X Y.
ppt-list [X|XS] Y :- ppt-list XS XSS, ppt X XT, Y is XT ^ " " ^ XSS.
ppt-list [] "".

% --------- typing  -------------------------------------------------------

pred unif i:typ, i:typ.
unif A B :- (A = B ; rm-any-variadic A A1, rm-any-variadic B B1, A1 = B1), !.

pred rm-any-variadic i:typ, o:typ.
rm-any-variadic (tconst S as C) X :- !, if (S = "any") (X = FRESH_) (X = C).
rm-any-variadic (tapp [tconst "variadic",_,X]) X1 :- !, rm-any-variadic X X1.
rm-any-variadic (tapp L) (tapp L1) :- !, rm-any-variadic-list L L1.
rm-any-variadic (ctype _ as X) X.
rm-any-variadic prop prop.
rm-any-variadic (arrow A1 B1) (arrow A2 B2) :- rm-any-variadic A1 A2, rm-any-variadic B1 B2.
rm-any-variadic (uvar as X) X.

mode (rm-any-variadic-list i o).
rm-any-variadic-list [] [].
rm-any-variadic-list [X|XS] [Y|YS] :- rm-any-variadic X Y, rm-any-variadic-list XS YS.

:index(2)
pred of i:term, o:typ.

of (cdata CData) Ty :-
  is_cdata CData (ctype CTy), !,
  assert (unif Ty (ctype CTy)) (type-err (cdata CData) (ctype CTy) Ty).

of (app [HD|ARGS]) TY :- !, 
  report-all-failures-if-no-success % HD may have multiple types
   (of HD HDTY, of-app HDTY ARGS TY HD (Done - Done)) _.
of (lam F) (arrow T B) :- !, pi x\
  (of x T :- !) => of (F x) B.

mode (of-app i i o o o).

:if "DEBUG:CHECKER"
of-app Ty Args Tgt Hd _ :-
  print {trace.counter "run"} "of-app" {pp Hd} ":" {ppt Ty} "@" {pp-list Args} "=" {ppt Tgt}, fail.

of-app (tapp [tconst "variadic", T, _] as V) [X|XS] TGT HD (B - BT) :- !,
  of X TX, assert (unif T TX) (type-err X TX T), BT = X :: TL, of-app V XS TGT HD (B - TL).
of-app (tapp [tconst "variadic", _, TS]) [] TGT HD (D - []) :- !,
  assert (unif TGT TS) (type-err (app [HD|D]) TS TGT).
of-app (arrow T TS) [X|XS] TGT HD (B - BT) :- !,
  of X TX, assert (unif T TX) (type-err X TX T), BT = X :: TL, of-app TS XS TGT HD (B - TL).
of-app (uvar as ARR)  [X|XS] TGT HD (B - BT) :- !,
  of X T, ARR = arrow T TS, BT = X :: TL, of-app TS XS TGT HD (B - TL).
of-app Ty [] TGT HD (D - []) :- !,
  assert (unif TGT Ty) (type-err (app [HD|D]) Ty TGT).
of-app (uvar as Ty)  [] TGT HD (D - []) :- !,
  assert (unif TGT Ty) (type-err (app [HD|D]) Ty TGT).

of-app Ty Args _ HD (D - []) :- !,
  assert false (wrong-arity (app [HD|D]) Ty Args).

mode (of-clause i i).
of-clause [N|NS] (arg C) :- !, pi x\ 
 (pp x N :- !) => (pi Tf\ of x Tf :- !, assert (unif T Tf) (type-err x T Tf)) =>
 of-clause NS (C x).
of-clause [] (arg C) :- !, pi x\ 
 (pi Tf\ of x Tf :- !, assert (unif T Tf) (type-err x T Tf)) =>
 of-clause [] (C x).
of-clause _ C :- of C TC, assert (unif TC prop) (type-err C TC prop).

type checking (ctype "Loc.t") -> prop.

:if "DEBUG:CHECKER"
log-tc-clause Loc Query :- !, print {trace.counter "run"} "typecheck" Loc Query.
log-tc-clause _ _.

mode (typecheck i i i i i).
typecheck P _ T0 NP _RC :- D is {gettimeofday} - T0, D > 10.0, !,
  print "[skipping" {std.length P} "clauses out of" NP "due to time limit]".

typecheck [] (clause Loc Names Query) _ _ RC :-
  log-tc-clause Loc Query,
  checking Loc =>
    report-all-failures-if-no-success (of-clause Names Query) RC.
typecheck [ (clause Loc Names Clause) | Rest] Q T0 NP RC :-
  log-tc-clause Loc Clause,
  checking Loc =>
    report-all-failures-if-no-success (of-clause Names Clause) RC, !,
  typecheck Rest Q T0 NP RC.

mode (refresh i o).
refresh (forall F) T :- !, refresh (F FRESH_) T.
refresh (tconst "any") FRESH_ :- !.
refresh X X.

% mode (safe-dest-app i o o).
safe-dest-app (app [X | A]) X A :- !.
safe-dest-app X X [].

collect-symbols-term N X X :- name N, !.
collect-symbols-term (cdata _) X X :- !.
collect-symbols-term (app []) X X :- !.
collect-symbols-term (app [HD|L]) Acc Res :- !,
  collect-symbols-term HD Acc Acc1,
  collect-symbols-term (app L) Acc1 Res.
collect-symbols-term (lam F) Acc Res :- !,
  pi x\ collect-symbols-term (F x) Acc Res.
collect-symbols-term (arg F) Acc Res :- !,
  pi x\ collect-symbols-term (F x) Acc Res.
collect-symbols-term (const S) Acc Res :- !,
  if (std.string.map.mem S Acc) (Res = Acc)
     (checking Loc, std.string.map.add S Loc Acc Res).

collect-symbols-clause (clause Loc _ C) Acc Res :-
  checking Loc => collect-symbols-term C Acc Res.

collect-symbols-program [ C | P ] Acc Res :-
  collect-symbols-clause C Acc Acc1,
  collect-symbols-program P Acc1 Res.
collect-symbols-program [] X X.

mode (under-env i i).

type known term -> prop.

mode (similar i i).
similar S1 S2 :-
  R is ".*\\." ^ {rex_replace "[\\+\\*]" "." S2},
  rex_match R S1.

mode (filter-similar i i o).
filter-similar [] _ [].
filter-similar [const K `: _ |KS] S [K|R] :- similar K S, !, filter-similar KS S R.
filter-similar [_|KS] S R :- filter-similar KS S R.

pred str_concat i:list string, o:string.
str_concat [] "".
str_concat [S|SS] R :- str_concat SS RR, R is S ^ " " ^ RR.

mode (warn-undeclared i i o).
warn-undeclared _Known (pr ( "main") _) ff :- !.
warn-undeclared _ (pr ( S) _) ff :- rex_match ".*\\.aux" S, !.
warn-undeclared _ (pr ( S) _) ff :- rex_match ".*\\.aux\\." S, !.
warn-undeclared Known (pr ( S) LOC) tt :-
  filter-similar Known S Hints,
  if (Hints = []) (H = "") (H is " Did you mean " ^ {str_concat Hints} ^ "?"),
  MSG is "constant " ^ S ^ " has no declared type." ^ H,
  warning LOC MSG.

mode (forall_uto10 i i i).
forall_uto10 [] _ _ :- !.
forall_uto10 [X|XS] N P :- N < 10, !,
  P X Done, !,
  if (Done = tt) (M is N + 1) (M = N),
  forall_uto10 XS M P.
forall_uto10 ([pr _ LOC|_] as L) _ _ :-
  Msg is "[suppressing " ^ {term_to_string {std.length L}} ^ " warnings]",
  warning LOC Msg.
  
mode (under-decl-env i i).
under-decl-env [] P :- P.
under-decl-env [ X `: PT | XS ] P :-
  %print "Assume" X PT,
  (pi Ty\ of X Ty :- refresh PT Ty) => known X => under-decl-env XS P.

under-undecl-env [] P :- P.
under-undecl-env [ pr X _ | XS ] P :-
  %print "Assume" X PT,
  (of (const X) Ty_ :- !) => under-undecl-env XS P.

mode (rm-known i i o).
rm-known (const N `: _) S S1 :- std.string.map.remove N S S1.

:if "TIME:CHECKER"
timing S P :- !, std.time P Time, print S Time.
timing _ P :- P.

pred check-all-symbols i:std.string.map loc.
:name "check-all-symbols:main"
check-all-symbols _.

mode (typecheck-program i i i o).
:name "typecheck-program:main"
typecheck-program P Q DeclaredTypes RC :-
  KnownTypes = [
    ((const "pi") `: forall x\ (arrow (arrow x prop) prop)),
    ((const "sigma") `: forall x\ (arrow (arrow x prop) prop)),
    ((const "discard") `: forall x\ x)|DeclaredTypes],
  timing "collect prog" (collect-symbols-program P {std.string.map.empty} TMP),
  collect-symbols-clause Q TMP AllSymbols,
  check-all-symbols AllSymbols,
  std.fold KnownTypes AllSymbols rm-known Unknown,
  std.string.map.bindings Unknown Undeclared,
  forall_uto10 {std.rev Undeclared} 0 (warn-undeclared KnownTypes), !,
  timing "typecheck "
         (under-decl-env {std.rev KnownTypes}
           (under-undecl-env Undeclared
             (typecheck P Q {gettimeofday} {std.length P} RC))).

% ---------- warnings ------------------------------------------------------
% elpi:skip 1
infix >>> 141.

type (>>>) term -> int -> entry.
type variable term -> prop.

pred silence-linear-warning i:string.
silence-linear-warning VN :- rex_match "^_.*" VN ; rex_match ".*_$" VN.

mode (report-linear i).
report-linear [].
report-linear [(V >>> 1 + uvar) |NS] :- !,
  pp V VN,
  if (not(silence-linear-warning VN))
    (checking LOC,
     MSG is VN ^" is linear: name it _" ^ VN ^
         " (discard) or " ^ VN ^ "_ (fresh variable)",
     warning LOC MSG)
    true,
  report-linear NS.
report-linear [(V >>> uvar) |NS] :-
  pp V VN,
  if (not(silence-linear-warning VN))
    (checking LOC, MSG is VN ^" is unused", warning LOC MSG)
    true,
  report-linear NS.
report-linear [(_ >>> _) | NS] :- report-linear NS.

type count A -> list B -> prop.
mode (count i i).
count (lam F) E :- pi x\ count (F x) E.
count (app [X|XS]) E :- !, count X E, count (app XS) E.
count (app []) _ :- !.
count X E :- variable X, !, incr X E.
count _ _.

mode (incr i i).
incr X [(X >>> K) | _] :- add1 K.
incr X [_ | XS] :- incr X XS.

mode (add1 i).
add1 (uvar as K) :- K = 1 + FRESH_.
add1 (1 + K) :- add1 K.

mode (check-non-linear i i i).
check-non-linear [N|NS] (arg C) L :- pi x\
 (pp x N :- !) => (variable x) => check-non-linear NS (C x) [(x >>> FRESH_) | L].
check-non-linear [] (arg C) L :- pi x\
 (variable x) => check-non-linear _ (C x) [(x >>> FRESH_) | L].
check-non-linear _ C L :-
  count C L, report-linear L.

mode (warn-linear i).
:name "warn-linear:main"
warn-linear [].
warn-linear [ (clause Loc Names Clause) |CS] :-
  checking Loc =>  check-non-linear Names Clause [],
  warn-linear CS.

% ---------- test ----------------------------------------------------------

main.

% ------- entry ---------------------------------------

mode (type->ppt-clause i i i o).
type->ppt-clause S ACC (forall F) (pi C) :- !,
  pi x\ type->ppt-clause S [x|ACC] (F x) (C x).
type->ppt-clause S [] T (pi Str\ ppt T Str :- !, ppt (tconst S) Str).
type->ppt-clause S ACC T (pi Str\ ppt T Str :- !, ppt (tapp [tconst S|Args]) Str) :- std.rev ACC Args.

mode (compile-type-abbreviations i o).
compile-type-abbreviations [] [].
compile-type-abbreviations [(_ `:= tconst _)|TS] Clauses :- !,
  % we don't refold immediate aliases
  compile-type-abbreviations TS Clauses.
compile-type-abbreviations [(X `:= ctype Y)|TS] Clauses :- not(X = Y), !,
  % we don't refold immediate aliases
  compile-type-abbreviations TS Clauses.
compile-type-abbreviations [(S `:= T)|TS] [Clause|Clauses] :-
  type->ppt-clause S [] T Clause,
  compile-type-abbreviations TS Clauses.

macro @rigid-term :- (cdata "rigid-term").

to-constant V :- V = @rigid-term.

mode (to-rigid-term i).
to-rigid-term N :- name N, !.
to-rigid-term V :- var V, !, to-constant V.
to-rigid-term (cdata (uvar _ as V)) :- !, to-constant V.
to-rigid-term (cdata _) :- !.
to-rigid-term (app L) :- !, std.forall L to-rigid-term.
to-rigid-term (lam F) :- !, pi x\ to-rigid-term (F x).
to-rigid-term (const _) :- !.
to-rigid-term A :- halt "Error in to-rigid-term" A.

mode (is-rigid-term i).
is-rigid-term N :- name N, !.
is-rigid-term V :- var V, !, fail.
is-rigid-term (cdata (uvar _ as V)) :- !, to-constant V.
is-rigid-term (cdata _) :- !.
is-rigid-term (app L) :- !, std.forall L is-rigid-term.
is-rigid-term (lam F) :- !, pi x\ is-rigid-term (F x).
is-rigid-term (const _) :- !.
is-rigid-term A :- halt "Error in is-rigid-term" A.

mode (build-mode i o).
build-mode L R :- std.map L (x\r\ r = false) R.

pred add-no-modes o:list A, i:A.
add-no-modes X T :- var X, !, X = [T|Y_], print "No mode for" T.
add-no-modes [X|_] Y :- not (var X), X = Y, !.
add-no-modes [X|Xs] T :- var Xs, !, print "No mode for" X, Xs = [T|Y_].
add-no-modes [_|Xs] T :- !, add-no-modes Xs T.

mode (find-mode i o i i o).
find-mode [] NoModes_ X _ _ :- fatal-no-mode, halt "Check-well-modes-negative: no mode for" X.
find-mode [] NoModes X Args R :- !, add-no-modes NoModes X, build-mode Args R .
find-mode [pr X R|_] _ X _ R :- !.
find-mode [_ | Xs] NoModes X Args R :- !, find-mode Xs NoModes X Args R.

mode (set-head-mode o i i i).
set-head-mode NoModes Head Args AllModes :-
  find-mode AllModes NoModes Head Args Mode, !,
  std.forall2 Mode Args (m\t\ if m (to-rigid-term t) true).
set-head-mode _ _ _ _.

mode (check-head-output i i i i i).
check-head-output NoModes Head Args AllModes Loc :-
  find-mode AllModes NoModes Head Args Mode, !, 
  std.forall2 Mode Args (m\t\ sigma Args'\
    if m true (if (is-rigid-term t) true (
      std.assert!(std.map Args get-str Args') "Should not fail",
      print "There is an output of\"" Head "\"that is not rigid" Args' Loc))).
check-head-output _ _ _ _ _.

mode (variadic-mode i).
variadic-mode (const "halt").
variadic-mode (const "print").

mode (is-ho-predicate i).
is-ho-predicate (@rigid-term).

pred map-var o:A, i:string, o:prop.
map-var V S R :- var V, !, R = (get-str X (cdata S) :- same_term X V, !).

pred get-str i:term, o:term.
get-str N N :- name N, !.
get-str (cdata _ as X) X :- !.
get-str (app L) (app L'):- !, std.map L get-str L'.
get-str (lam F) (lam F') :- !, pi x\ get-str (F x) (F' x).
get-str (const T) (const T) :- !.
get-str A A :- var A, !.
get-str A _ :- halt "Error in get-str" A.

pred check-args-mode i:D, o:A, i:B, i:C, i:prop, i:term.
check-args-mode HD _ _ Loc Mode Arg :-
  Mode, var Arg, !,
  std.assert!(get-str Arg Arg') "Should not fail",
  if (fatal-no-mode) (halt "WARNING: Flex arg" Arg' "passed to" HD Loc) (print "WARNING: Flex arg" Arg' "passed to" HD Loc).
% TODO: following rule aims to go under lambda which are args of a predicate
%       however, this is gives a error if partial application is used
% check-args-mode _ NoModes AllModes Loc Mode Arg :-
%   Mode, Arg = lam L, !,
%   print ("Going under lambda") Arg,
%   pi x\ std.assert!(check-well-moded-negative NoModes AllModes Loc (L x)) "Should not fail".
check-args-mode _ _ _ _ Mode Arg :- Mode, !.
check-args-mode _ _ _ _ Mode Arg :- 
  not Mode, to-rigid-term Arg.

mode (check-well-moded-negative o i i i).
check-well-moded-negative _ _ _        N :- name N, !.
% check-well-moded-negative _ _ _        V :- var V, !, to-constant V.
check-well-moded-negative _ _ _        (cdata (uvar _ as V)) :- !, to-constant V.
check-well-moded-negative _ _ _        (cdata _) :- !.
check-well-moded-negative NoModes AllModes Loc (app [const "," | L]) :- !,
  std.forall L (x\ if (var x) ((fatal-no-mode, halt "Passed flexible to ," Loc); print "Passed flexible to ," Loc) (check-well-moded-negative NoModes AllModes Loc x)).
check-well-moded-negative NoModes AllModes Loc (app [const "pi", lam B]) :- !,
  pi x\ check-well-moded-negative NoModes AllModes Loc (B x).
check-well-moded-negative NoModes AllModes Loc (app [const "=>", Hyp, Body]) :- !,
  check-well-moded-positive NoModes Hyp AllModes Loc [],
  check-well-moded-negative NoModes AllModes Loc Body.
check-well-moded-negative _ _ _ (app [HD|_]) :- variadic-mode HD, !.
check-well-moded-negative NoModes AllModes Loc (app [HD|Args]) :- !,
  find-mode AllModes NoModes HD Args Mode,
  if ({std.length Mode} = {std.length Args}) true (halt "Invalid mode length for" HD Loc),
  std.forall2 Mode Args (x\y\std.assert!(check-args-mode HD NoModes AllModes Loc x y) "Mh").
check-well-moded-negative NoModes AllModes Loc (lam F) :- !, 
  pi x\ check-well-moded-negative NoModes AllModes Loc (F x).
check-well-moded-negative _ _ _       (const _ as _) :- !.

mode (check-well-moded-negative-list i o i i).
check-well-moded-negative-list [] _ _ _ :- !.
check-well-moded-negative-list [X | Xs] NoModes Modes Loc :-
  check-well-moded-negative NoModes Modes Loc X,
  check-well-moded-negative-list Xs NoModes Modes Loc.

mode (to-check i).
to-check _ :- !, true.
% to-check (const "a") :- !.
% to-check (const "b") :- !.
% to-check (const "c") :- !.
% to-check (arg B) :- !, pi x\ to-check (B x).
% to-check (app [(const ":-"), (app [Head | _]) | _]) :- !,
%   to-check Head.

% mode (check-well-moded-positive i i i i).
pred check-well-moded-positive o:A, i:B, i:C, i:D, i:E.
check-well-moded-positive _ X _ _ _ :- var X, halt "Got uvar in check well-moded-positive".
check-well-moded-positive NoModes (arg B) Modes Loc [N|Names] :- !,
  map-var X N P,
  P => check-well-moded-positive NoModes (B X) Modes Loc Names.
check-well-moded-positive _ (const _) _ _ _ :- !.
check-well-moded-positive NoModes (app [(const ":-"), (app [Head | Args]) | Prem]) Modes Loc Names_ :-
  set-head-mode NoModes Head Args Modes, 
  check-well-moded-negative-list Prem NoModes Modes Loc,
  check-head-output NoModes Head Args Modes Loc.
check-well-moded-positive NoModes (app [(const ":-"), (const _) | Prem]) Modes Loc Names_ :- !,
   check-well-moded-negative-list Prem NoModes Modes Loc.
check-well-moded-positive NoModes (app [(const "pi"), lam B]) Modes Loc Names :- !,
  check-well-moded-positive NoModes (B X_) Modes Loc Names.
check-well-moded-positive NoModes (app [(const ",") | L]) Modes Loc Names :- !,
  std.forall L (x\ check-well-moded-positive NoModes x Modes Loc Names).
check-well-moded-positive NoModes (app ([const "::", A, L])) Modes Loc Names :- !,
  check-well-moded-positive NoModes A Modes Loc Names,
  check-well-moded-positive NoModes L Modes Loc Names.
check-well-moded-positive _ (app _) _ _ _ :- !. % print "TODO: for" T.
check-well-moded-positive _ (@rigid-term) _ _ _ :- !.

check-well-moded-positive _ A _ _ _ :- halt "check-well-moded-positive: Uncaught branch in" A.

mode (check-well-moded-prog i i).
check-well-moded-prog [] _ :- !.
check-well-moded-prog [clause Loc Vars Body | Tl] Modes :-
  to-check Body, !,
  % print "Going to check" Loc Body,
  check-well-moded-positive NoModes_ Body Modes Loc Vars, !,
  check-well-moded-prog Tl Modes.

check-overlapping-prog [] _ :- !.

mode (check i i i i i i).
:name "check:main"
check P Q DeclaredTypes TypeAbbreviations Modes _FuncPred :-
  compile-type-abbreviations TypeAbbreviations Abbrevs,
  Abbrevs => typecheck-program P Q DeclaredTypes RC, !,
  warn-linear P, !,
  if (var RC) (true) (fail),
  check-well-moded-prog P Modes.

% vim: set ft=lprolog:
